# SpringIOC分析

## Web IOC容器

从大家熟悉的DispatcherServlet开始，最先执行的是`init()`方法。但是经过探索，往上追索在其父类HttpServletBean找到`init()`方法

```
/**
 * Map config parameters onto bean properties of this servlet, and
 * invoke subclass initialization.
 * @throws ServletException if bean properties are invalid (or required
 * properties are missing), or if subclass initialization fails.
 */
@Override
public final void init() throws ServletException {
	if (logger.isDebugEnabled()) {
		logger.debug("Initializing servlet '" + getServletName() + "'");
	}

	// Set bean properties from init parameters.
	PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
	if (!pvs.isEmpty()) {
		try {
			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
			ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
			bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
			initBeanWrapper(bw);
			bw.setPropertyValues(pvs, true);
		}
		catch (BeansException ex) {
			if (logger.isErrorEnabled()) {
				logger.error("Failed to set bean properties on servlet '" + getServletName() + "'", ex);
			}
			throw ex;
		}
	}

	// Let subclasses do whatever initialization they like.
	initServletBean();

	if (logger.isDebugEnabled()) {
		logger.debug("Servlet '" + getServletName() + "' configured successfully");
	}
}
```
在init()方法中，真正完成初始化容器的逻辑在`initServletBean()`方法中，找到代码在FrameworkServlet类中：

```
/**
 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
 * have been set. Creates this servlet's WebApplicationContext.
 */
@Override
protected final void initServletBean() throws ServletException {
	getServletContext().log("Initializing Spring FrameworkServlet '" + getServletName() + "'");
	if (logger.isInfoEnabled()) {
		logger.info("FrameworkServlet '" + getServletName() + "': initialization started");
	}
	long startTime = System.currentTimeMillis();

	try {
		this.webApplicationContext = initWebApplicationContext();
		initFrameworkServlet();
	}
	catch (ServletException | RuntimeException ex) {
		logger.error("Context initialization failed", ex);
		throw ex;
	}

	if (logger.isInfoEnabled()) {
		long elapsedTime = System.currentTimeMillis() - startTime;
		logger.info("FrameworkServlet '" + getServletName() + "': initialization completed in " +
				elapsedTime + " ms");
	}
}
```

终于看到了`initWebApplicationContext()`方法：

```
/**
 * Initialize and publish the WebApplicationContext for this servlet.
 * <p>Delegates to {@link #createWebApplicationContext} for actual creation
 * of the context. Can be overridden in subclasses.
 * @return the WebApplicationContext instance
 * @see #FrameworkServlet(WebApplicationContext)
 * @see #setContextClass
 * @see #setContextConfigLocation
 */
protected WebApplicationContext initWebApplicationContext() {

	// 先从ServletContext中获得父容器WebAppliationContext
	WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());
	// 声明子容器
	WebApplicationContext wac = null;

	// 建立父、子容器之间的关联关系
	if (this.webApplicationContext != null) {
		// A context instance was injected at construction time -> use it
		wac = this.webApplicationContext;
		if (wac instanceof ConfigurableWebApplicationContext) {
			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
			if (!cwac.isActive()) {
				// The context has not yet been refreshed -> provide services such as
				// setting the parent context, setting the application context id, etc
				if (cwac.getParent() == null) {
					// The context instance was injected without an explicit parent -> set
					// the root application context (if any; may be null) as the parent
					cwac.setParent(rootContext);
				}
				configureAndRefreshWebApplicationContext(cwac);
			}
		}
	}
	// 先去ServletContext中查找Web容器的引用是否存在，并创建好默认的空IOC容器
	if (wac == null) {
		// No context instance was injected at construction time -> see if one
		// has been registered in the servlet context. If one exists, it is assumed
		// that the parent context (if any) has already been set and that the
		// user has performed any initialization such as setting the context id
		wac = findWebApplicationContext();
	}
	// 给上一步创建好的IOC容器赋值
	if (wac == null) {
		// No context instance is defined for this servlet -> create a local one
		wac = createWebApplicationContext(rootContext);
	}
	// 触发onRefresh方法
	if (!this.refreshEventReceived) {
		// Either the context is not a ConfigurableApplicationContext with refresh
		// support or the context injected at construction time had already been
		// refreshed -> trigger initial onRefresh manually here.
		synchronized (this.onRefreshMonitor) {
			onRefresh(wac);
		}
	}

	if (this.publishContext) {
		// Publish the context as a servlet context attribute.
		String attrName = getServletContextAttributeName();
		getServletContext().setAttribute(attrName, wac);
		if (this.logger.isDebugEnabled()) {
			this.logger.debug("Published WebApplicationContext of servlet '" + getServletName() +
					"' as ServletContext attribute with name [" + attrName + "]");
		}
	}

	return wac;
}

/**
 * Retrieve a {@code WebApplicationContext} from the {@code ServletContext}
 * attribute with the {@link #setContextAttribute configured name}. The
 * {@code WebApplicationContext} must have already been loaded and stored in the
 * {@code ServletContext} before this servlet gets initialized (or invoked).
 * <p>Subclasses may override this method to provide a different
 * {@code WebApplicationContext} retrieval strategy.
 * @return the WebApplicationContext for this servlet, or {@code null} if not found
 * @see #getContextAttribute()
 */
@Nullable
protected WebApplicationContext findWebApplicationContext() {
	String attrName = getContextAttribute();
	if (attrName == null) {
		return null;
	}
	WebApplicationContext wac =
			WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName);
	if (wac == null) {
		throw new IllegalStateException("No WebApplicationContext found: initializer not registered?");
	}
	return wac;
}

/**
 * Instantiate the WebApplicationContext for this servlet, either a default
 * {@link org.springframework.web.context.support.XmlWebApplicationContext}
 * or a {@link #setContextClass custom context class}, if set.
 * <p>This implementation expects custom contexts to implement the
 * {@link org.springframework.web.context.ConfigurableWebApplicationContext}
 * interface. Can be overridden in subclasses.
 * <p>Do not forget to register this servlet instance as application listener on the
 * created context (for triggering its {@link #onRefresh callback}, and to call
 * {@link org.springframework.context.ConfigurableApplicationContext#refresh()}
 * before returning the context instance.
 * @param parent the parent ApplicationContext to use, or {@code null} if none
 * @return the WebApplicationContext for this servlet
 * @see org.springframework.web.context.support.XmlWebApplicationContext
 */
protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {
	Class<?> contextClass = getContextClass();
	if (this.logger.isDebugEnabled()) {
		this.logger.debug("Servlet with name '" + getServletName() +
				"' will try to create custom WebApplicationContext context of class '" +
				contextClass.getName() + "'" + ", using parent context [" + parent + "]");
	}
	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
		throw new ApplicationContextException(
				"Fatal initialization error in servlet with name '" + getServletName() +
				"': custom WebApplicationContext class [" + contextClass.getName() +
				"] is not of type ConfigurableWebApplicationContext");
	}
	ConfigurableWebApplicationContext wac =
			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

	wac.setEnvironment(getEnvironment());
	wac.setParent(parent);
	String configLocation = getContextConfigLocation();
	if (configLocation != null) {
		wac.setConfigLocation(configLocation);
	}
	configureAndRefreshWebApplicationContext(wac);

	return wac;
}

protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
	if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
		// The application context id is still set to its original default value
		// -> assign a more useful id based on available information
		if (this.contextId != null) {
			wac.setId(this.contextId);
		}
		else {
			// Generate default id...
			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
					ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName());
		}
	}

	wac.setServletContext(getServletContext());
	wac.setServletConfig(getServletConfig());
	wac.setNamespace(getNamespace());
	wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));

	// The wac environment's #initPropertySources will be called in any case when the context
	// is refreshed; do it eagerly here to ensure servlet property sources are in place for
	// use in any post-processing or initialization that occurs below prior to #refresh
	ConfigurableEnvironment env = wac.getEnvironment();
	if (env instanceof ConfigurableWebEnvironment) {
		((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());
	}

	postProcessWebApplicationContext(wac);
	applyInitializers(wac);
	wac.refresh();
}
```

从上面的代码中可以看出，在configAndRefreshWebApplicationContext0方法中，调用refresh()方法，这个是真正启动IOC容器的入口，后面会详细介绍。IOC容器初始化以后，最后调用了DispatcherServlet的 onRefresh()方法，在onRefresh()方法中又是直接调用initStrategies()方法初始化SpringMVC的九大组件：

```java
/**
 * This implementation calls {@link #initStrategies}.
 */
@Override
protected void onRefresh(ApplicationContext context) {
	initStrategies(context);
}

/**
 * Initialize the strategy objects that this servlet uses.
 * <p>May be overridden in subclasses in order to initialize further strategy objects.
 */
protected void initStrategies(ApplicationContext context) {
	// 多文件上传组件
	initMultipartResolver(context);
	// 初始化本地语言环境
	initLocaleResolver(context);
	// 初始化模板处理器
	initThemeResolver(context);
	// handlerMappeing
	initHandlerMappings(context);
	// 初始哈参数适配器
	initHandlerAdapters(context);
	// 初始化异常拦截器
	initHandlerExceptionResolvers(context);
	// 初始化视图预处理器
	initRequestToViewNameTranslator(context);
	// 初始化视图转换器
	initViewResolvers(context);
	initFlashMapManager(context);
}
```

## 基于XML的IOC容器初始化

IOC容器的初始化包括BeanDefinition的Resource定位、加载和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext 系列容器也许是我们最熟悉的，因为Web项目中使用的XmlWebApplicationContext 就属于这个继承体系还有ClasspathXmlApplicationContext等，其继承体系如下图所示：

![image](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Spring/spring_2020-08-09_21-34-39.jpg)

ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于Bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的Bean定义环境。

### 1.寻找入口

还有一个我们用的比较多的ClassPathXmlApplicationContext，通过main（）方法启动：
```
ApplicationContext app = new ClassPathxmlApplicationContext("application.xml"); 
```
先看其构造函数的调用：
```
public ClassPathxmlApplicationContext(String configlocation)throws BeansException{ 
    this(new String[]{configlocation}, true, (ApplicationContext) nul1); 
}
```
其实际调用的构造函数为：
```
public ClassPathxmlApplicationContext(String[] configlocations,boolean refresh,@Nullable ApplicationContext parent) throws BeansException { 
    super(parent);
    this.setconfigLocations(configlocations);
    if (refresh) { 
        this.refresh();
    }
}
```
还有像AnnotationConfigApplicationContext、FileSystemXmlApplicationContext、 XmlWebApplicationContext等都继承自父容器AbstractApplicationContext主要用到了装饰器模式 和策略模式，最终都是调用refresh()方法。

### 2.获得配置路径

通过分析ClassPathXmlApplicationContext的源代码可以知道，在创建ClassPathXmlApplicationContext 容器时，构造方法做以下两项重要工作：

首先，调用父类容器的构造方法(super(parent)方法)为容器设置好Bean 资源加载器。然后，再调用父类AbstractRefreshableConfigApplicationContext 的setConfigLocations(configLocations)方法设置Bean配置信息的定位路径。
通过追踪ClassPathXmlApplicationContext的继承体系，发现其父类的父类AbstractApplicationContext中初始化IOC容器所做的主要源码如下：

```
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext {
	   
	static {
		// Eagerly load the ContextClosedEvent class to avoid weird classloader issues
		// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)
		// 为了避免应用程序在Weblogic8.1关闭是出现类加载异常加载问题，加载IOC容器关闭事件(ContextClosedEvent)类
		ContextClosedEvent.class.getName();
	}
	
	/**
	 * Create a new AbstractApplicationContext with no parent.
	 */
	public AbstractApplicationContext() {
		this.resourcePatternResolver = getResourcePatternResolver();
	}

	/**
	 * Create a new AbstractApplicationContext with the given parent context.
	 * @param parent the parent context
	 */
	public AbstractApplicationContext(@Nullable ApplicationContext parent) {
		this();
		setParent(parent);
	}
		
	// 获取一个Spring Source的加载器用于读入SpringBean配置信息
	// AbstractApplicationContext默认构造方法中有调用 PathMatchingResourcePatternResolver 构造方法
	// 创建Spring资源加载器
	protected ResourcePatternResolver getResourcePatternResolver() {
		return new PathMatchingResourcePatternResolver(this);
	}
}
```
在设置容器的资源加载器之后，接下来ClassPathXmlApplicationContext 执行 setConfigLocations()方法通过调用其父类AbstractRefreshableConfigApplicationContext的方法进行对Bean配置信息的定位，该方法的源码如下：

```
/**
 * Set the config locations for this application context in init-param style,
 * i.e. with distinct locations separated by commas, semicolons or whitespace.
 * <p>If not set, the implementation may use a default as appropriate.
 */
// 处理单个资源文件路径为一个字符串情况
public void setConfigLocation(String location) {
	// 多个资源文件路径之间可以用 ",; \t\n" 分割
	setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));
}
/**
 * 保存需要加载的本地资源 例如：application.xml
 * Set the config locations for this application context.
 * <p>If not set, the implementation may use a default as appropriate.
 */
public void setConfigLocations(@Nullable String... locations) {
	if (locations != null) {
		Assert.noNullElements(locations, "Config locations must not be null");
		this.configLocations = new String[locations.length];
		for (int i = 0; i < locations.length; i++) {
			// resolvePath 为同一个类中将字符串解析为路径的方法
			this.configLocations[i] = resolvePath(locations[i]).trim();
		}
	}
	else {
		this.configLocations = null;
	}
}

```
通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean配置信息，也可以使用字符串数组，即下面两种方式都是可以的：
```
ClassPathResource res=new ClassPathResource("a.xml,b.xml");
```
多个资源文件路径之间可以是用",;\t\r"等分隔。
```
ClassPathResource res =new ClassPathResource(new String[]{"a.xml","b.xml"});
```
至此，SpringlOC容器在初始化时将配置的Bean 配置信息定位为Spring封装的Resource。

### 3.开始启动

SpringlOC容器对Bean配置资源的载入是从refresh()函数开始的，refresh()是一个模板方法，规定了IOC容器的启动流程，有些逻辑要交给其子类去实现。它对Bean配置资源进行载入ClassPathXmlApplicationContext 通过调用其父类AbstractApplicationContext的refresh()函数启动整个IOC容器对Bean定义的载入过程，现在我们来详细看看refresh()中的逻辑处理：

```
// 启动整个IOC容器对Bean定义的载入过程
@Override
public void refresh() throws BeansException, IllegalStateException {
	synchronized (this.startupShutdownMonitor) {
		// Prepare this context for refreshing.
		// 1.调用容器准备刷新的方法获取勇气的当时时间，同时给容器设置同步标识
		prepareRefresh();

		// Tell the subclass to refresh the internal bean factory.
		// 2.告诉子类启动 refreshBeanFactory() 方法，Bean定义资源文件的载入从子类的 refreshBeanFactory() 方法启动
		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

		// Prepare the bean factory for use in this context.
		// 3.为Beanfactory配置容器特性，例如类加载器，事件处理器等
		prepareBeanFactory(beanFactory);

		try {
			// Allows post-processing of the bean factory in context subclasses.
			// 4.为容器的某些子类指定特殊的BeanPost事件处理器
			postProcessBeanFactory(beanFactory);

			// Invoke factory processors registered as beans in the context.
			// 5.调用所有注册的 BeanFactoryPostProcessors 的Bean
			invokeBeanFactoryPostProcessors(beanFactory);

			// Register bean processors that intercept bean creation.
			// 6.为beanFactory 注册 BeanPost事件处理器
			registerBeanPostProcessors(beanFactory);

			// Initialize message source for this context.
			// 7.初始化信息源，和国际化相关
			initMessageSource();

			// Initialize event multicaster for this context.
			// 8.初始化容器事件传播器
			initApplicationEventMulticaster();

			// Initialize other special beans in specific context subclasses.
			// 9.调用子类的某些特殊Bean初始化方法
			onRefresh();

			// Check for listener beans and register them.
			// 10.为事件传播器注册事件监听器
			registerListeners();

			// Instantiate all remaining (non-lazy-init) singletons.
			// 11.初始化所有神域的单例Bean
			finishBeanFactoryInitialization(beanFactory);

			// Last step: publish corresponding event.
			// 12.初始化容器的生命周期事件处理器，并发布容器的生命周期事件
			finishRefresh();
		}

		catch (BeansException ex) {
			if (logger.isWarnEnabled()) {
				logger.warn("Exception encountered during context initialization - " +
						"cancelling refresh attempt: " + ex);
			}

			// Destroy already created singletons to avoid dangling resources.
			// 13.销毁已创建的Bean
			destroyBeans();

			// Reset 'active' flag.
			// 14.起效refresh操作，重置容器的同步标识
			cancelRefresh(ex);

			// Propagate exception to caller.
			throw ex;
		}

		finally {
			// Reset common introspection caches in Spring's core, since we
			// might not ever need metadata for singleton beans anymore...
			// 15.重设公共缓存
			resetCommonCaches();
		}
	}
}
```
refresh()方法主要为IOC容器Bean的生命周期管理提供条件，Spring IOC 容器载入Bean配置信息从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中    "`ConfigurablelListableBeanFactory beanFactory = obtainFreshBeanfactory();`"这句以后代码的都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。

refresh()方法的主要作用是：在创建IOC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IOC容器。它类似于对IOC容器的重启，在新建立好的容器中对容器进行初始化，对Bean配置资源进行载入。

### 4.创建容器

obtainFreshBeanfactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入Bean配置信息的过程，代码如下：

```
/**
 * Tell the subclass to refresh the internal bean factory.
 * @return the fresh BeanFactory instance
 * @see #refreshBeanFactory()
 * @see #getBeanFactory()
 */
// 注册容器信息源和生命周期事件
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
	// 这里使用了委派模式，父类定义抽象 refreshBeanFactory() 方法，具体实现调用子类容器
	// 的 refreshBeanFactory() 方法
	refreshBeanFactory();
	ConfigurableListableBeanFactory beanFactory = getBeanFactory();
	if (logger.isDebugEnabled()) {
		logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
	}
	return beanFactory;
}
```
AbstractApplicationContext 类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是 其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，方法的源 码如下：

```
/**
 * This implementation performs an actual refresh of this context's underlying
 * bean factory, shutting down the previous bean factory (if any) and
 * initializing a fresh bean factory for the next phase of the context's lifecycle.
 */
@Override
protected final void refreshBeanFactory() throws BeansException {
	// 如果已经有容器，销毁容器中的bean，关闭容器
	if (hasBeanFactory()) {
		destroyBeans();
		closeBeanFactory();
	}
	try {
		// 创建IOC容器
		DefaultListableBeanFactory beanFactory = createBeanFactory();
		beanFactory.setSerializationId(getId());
		// 对IOC容器进行定制化，如设置启动参数，开启注解的自动装配等
		customizeBeanFactory(beanFactory);
		// 调用载入bean 定义的方法，主要这里又使用了委派模式，在当前类中定义了抽象
		// 的 loadBeanDefinitions 方法，具体的实现调用子类容器
		loadBeanDefinitions(beanFactory);
		this.beanFactory = beanFactory;
	}
	catch (IOException ex) {
		throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
	}
}
```
在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁 beans并关闭beanFactory，接着 创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载 bean定义。

### 5.载入配置路径 

AbstractRefreshableApplicationContext中只定义了抽象的loadBeanDefinitions 方法，容器真正调 用的是其子类AbstractXmlApplicationContext对该方法的实现，AbstractXmlApplicationContext 的主要源码如下：

loadBeanDefinitions0方法同样是抽象方法，是由其子类实现的，也即在 AbstractXmlApplicationContext中。

```
/**
 * Loads the bean definitions via an XmlBeanDefinitionReader.
 * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
 * @see #initBeanDefinitionReader
 * @see #loadBeanDefinitions
 */
// 实现父类抽象的载入Bean方法
@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
	// 创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean配置资源
	// Create a new XmlBeanDefinitionReader for the given BeanFactory.
	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

	// Configure the bean definition reader with this context's
	// resource loading environment.
	//
	beanDefinitionReader.setEnvironment(this.getEnvironment());
	beanDefinitionReader.setResourceLoader(this);
	// 为Bean读取器设置SAX xml解析器
	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

	// Allow a subclass to provide custom initialization of the reader,
	// then proceed with actually loading the bean definitions.
	// 当bean读取器读取bean定义的xml资源文件时，启用xml的校验机制
	initBeanDefinitionReader(beanDefinitionReader);
	// bean读取器真正实现加载的方法
	loadBeanDefinitions(beanDefinitionReader);
}
/**
 * Initialize the bean definition reader used for loading the bean
 * definitions of this context. Default implementation is empty.
 * <p>Can be overridden in subclasses, e.g. for turning off XML validation
 * or using a different XmlBeanDefinitionParser implementation.
 * @param reader the bean definition reader used by this context
 * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader#setDocumentReaderClass
 */
protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {
	reader.setValidating(this.validating);
}

/**
 * Load the bean definitions with the given XmlBeanDefinitionReader.
 * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}
 * method; hence this method is just supposed to load and/or register bean definitions.
 * @param reader the XmlBeanDefinitionReader to use
 * @throws BeansException in case of bean registration errors
 * @throws IOException if the required XML document isn't found
 * @see #refreshBeanFactory
 * @see #getConfigLocations
 * @see #getResources
 * @see #getResourcePatternResolver
 */
// xml bean读取器加载bean配置资源
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
	// 获取bean配置资源的定位
	Resource[] configResources = getConfigResources();
	if (configResources != null) {
		// xml bean读取器调用其父类AbstractBeanDefinitionReader读取定位的bean配置资源
		reader.loadBeanDefinitions(configResources);
	}
	// 如果子类中获取的bean配置资源定位为空，则获取ClassPathXmlApplicationContext
	// 构造方法中setConfigLocations方法设置的资源
	String[] configLocations = getConfigLocations();
	if (configLocations != null) {
		// XML bean读取器调用其父类AbstractBenaDefinitionReader读取定位的Bean配置资源
		reader.loadBeanDefinitions(configLocations);
	}
}

/**
 * Return an array of Resource objects, referring to the XML bean definition
 * files that this context should be built with.
 * <p>The default implementation returns {@code null}. Subclasses can override
 * this to provide pre-built Resource objects rather than location Strings.
 * @return an array of Resource objects, or {@code null} if none
 * @see #getConfigLocations()
 */
// 这里又使用委派模式，调用子类获取bean配置资源定位的方法
// 该方法在ClassPathXmlApplicationContext中进行实现
@Nullable
protected Resource[] getConfigResources() {
	return null;
}
```
以XmlBean读取器的其中一种策略XmlBeanDefinitionReader为例。XmlBeanDefinitionReader调 用其父类AbstractBeanDefinitionReader的reader.loadBeanDefinitions()方法读取Bean配置资源。
由于我们使用ClassPathXmlApplicationContext作为例子分析，因此getConfigResources的返回值 为null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。


### 6.分配路径处理策略 

在XmlBeanDefinitionReader的抽象父类AbstractBeanDefinitionReader中定义了载入过程。

AbstractBeanDefinitionReader的 loadBeanDefinitions0方法源码如下：

```
@Override
public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
	return loadBeanDefinitions(location, null);
}

/**
 * Load bean definitions from the specified resource location.
 * <p>The location can also be a location pattern, provided that the
 * ResourceLoader of this bean definition reader is a ResourcePatternResolver.
 * @param location the resource location, to be loaded with the ResourceLoader
 * (or ResourcePatternResolver) of this bean definition reader
 * @param actualResources a Set to be filled with the actual Resource objects
 * that have been resolved during the loading process. May be {@code null}
 * to indicate that the caller is not interested in those Resource objects.
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of loading or parsing errors
 * @see #getResourceLoader()
 * @see #loadBeanDefinitions(org.springframework.core.io.Resource)
 * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])
 */
public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
	// 获取在IOC容器初始化过程中设置的资源加载器
	ResourceLoader resourceLoader = getResourceLoader();
	if (resourceLoader == null) {
		throw new BeanDefinitionStoreException(
				"Cannot import bean definitions from location [" + location + "]: no ResourceLoader available");
	}

	if (resourceLoader instanceof ResourcePatternResolver) {
		// Resource pattern matching available.
		try {
			// 将指定位置的bean配置信息解析为SpirngIOC容器封装的资源
			// 加载多个指定位置的bean配置信息
			Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
			// 委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能
			int loadCount = loadBeanDefinitions(resources);
			if (actualResources != null) {
				for (Resource resource : resources) {
					actualResources.add(resource);
				}
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Loaded " + loadCount + " bean definitions from location pattern [" + location + "]");
			}
			return loadCount;
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					"Could not resolve bean definition resource pattern [" + location + "]", ex);
		}
	}
	else {
		// Can only load single resources by absolute URL.
		// 将制定位置的Bean配置信息解析为SpringIOC容器封装的资源
		// 加载单个指定位置的bean配置信息
		Resource resource = resourceLoader.getResource(location);
		// 委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能
		int loadCount = loadBeanDefinitions(resource);
		if (actualResources != null) {
			actualResources.add(resource);
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Loaded " + loadCount + " bean definitions from location [" + location + "]");
		}
		return loadCount;
	}
}

// 重载方法，调用loadBeanDefinitions
@Override
public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
	Assert.notNull(locations, "Location array must not be null");
	int counter = 0;
	for (String location : locations) {
		counter += loadBeanDefinitions(location);
	}
	return counter;
}
```

AbstractRefreshableConfigApplicationContext的 loadBeanDefinitions(Resource... resources)方 法实际上是调用AbstractBeanDefinitionReader的loadBeanDefinitions0方法。

从对AbstractBeanDefinitionReader的loadBeanDefinitions()方法源码分析可以看出该方法就做了 两件事：

首先，调用资源加载器的获取资源方法resourceLoadergetResource(location)获取到要加载的资源。
其次，真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions()方法。在 loadBeanDefinitions()方法中调用了AbstractApplicationContext的getResources()方法，跟进去之 后发现getResources()方法其实定义在ResourcePatternResolver中，此时，我们有必要来看一下 ResourcePatternResolver的全类图：

![image](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Spring/Spring_2020-08-09_21-57-02.jpg)

![image](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Spring/spring_2020-08-09_21-34-39.jpg)

从上面可以看到ResourceLoader与ApplicationContext的继承关系，可以看出其实际调用的是 DefaultResourceloader 中的getSource()方法定位Resource，因为 ClassPathXmlApplicationContext 本身就是DefaultResourceLoader的实现类，所以此时又回到了 ClassPathXmlApplicationContext中来。

### 7.解析配置文件路径 

XmlBeanDefinitionReader 通过调用ClassPathXmlApplicationContext的父类 DefaultResourceLoader的 getResource()方法获取要加载的资源，其源码如下

```
@Override
public Resource getResource(String location) {
	Assert.notNull(location, "Location must not be null");

	for (ProtocolResolver protocolResolver : this.protocolResolvers) {
		Resource resource = protocolResolver.resolve(location, this);
		if (resource != null) {
			return resource;
		}
	}
	// 如果是类路径的方式，那需要使用ClassPathResource来得到Bean文件的资源对象
	if (location.startsWith("/")) {
		return getResourceByPath(location);
	}
	// classPath: 方式
	else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
		return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
	}
	else {
		try {
			// Try to parse the location as a URL...
			// 如果是URL方式，使用UrlResource作为bean文件资源对象
			URL url = new URL(location);
			return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
		}
		catch (MalformedURLException ex) {
			// No URL -> resolve as resource path.
			// 如果既不是classpath标识。又不是URL标识的Resource定位，则调用
			// 容器本身的getResourceBayPath方法获取Resource
			return getResourceByPath(location);
		}
	}
}
```
DefaultResourceloader 提供了 getResourceByPath()方法的实现，就是为了处理既不是classpath标识，又不是URL标识的Resource定位这种情况。
```
protected Resource getResourceByPath(String path) {
    return new ClassPathContextResource(path, getClassLoader());
}
```
在ClassPathResource中完成了对整个路径的解析。这样，就可以从类路径上对IOC配置文件进行加载，当然我们可以按照这个逻辑从任何地方加载，在Spring中我们看到它提供的各种资源抽象，比如ClassPathResource、URLResource、FileSystemResource 等来供我们使用。上面我们看到的是定位Resource的一个过程，而这只是加载过程的一部分。例如FileSystemXmlApplicationContext 容器就重写了getResourceByPath()方法：

```
/**
 * Resolve resource paths as file system paths.
 * <p>Note: Even if a given path starts with a slash, it will get
 * interpreted as relative to the current VM working directory.
 * This is consistent with the semantics in a Servlet container.
 * @param path path to the resource
 * @return Resource handle
 * @see org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath
 */
@Override
protected Resource getResourceByPath(String path) {
	if (path.startsWith("/")) {
		path = path.substring(1);
	}
	return new FileSystemResource(path);
}
```
通过子类覆盖，巧妙地完成了将类路径变为文件路径的转换

### 8.开始读取配置内容

继续回到XmlBeanDefinitionReader的loadBeanDefinitions(Resource..)方法看到代表bean文件 的资源定义以后的载入过程。

```
/**
 * Load bean definitions from the specified XML file.
 * @param resource the resource descriptor for the XML file
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of loading or parsing errors
 */
@Override
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
	// 将读入的XML资源进行特殊编码处理
	return loadBeanDefinitions(new EncodedResource(resource));
}

/**
 * Load bean definitions from the specified XML file.
 * @param encodedResource the resource descriptor for the XML file,
 * allowing to specify an encoding to use for parsing the file
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of loading or parsing errors
 */
// 这里是载入xml形式bean配置信息方法
public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
	Assert.notNull(encodedResource, "EncodedResource must not be null");
	if (logger.isInfoEnabled()) {
		logger.info("Loading XML bean definitions from " + encodedResource);
	}

	Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();
	if (currentResources == null) {
		currentResources = new HashSet<>(4);
		this.resourcesCurrentlyBeingLoaded.set(currentResources);
	}
	if (!currentResources.add(encodedResource)) {
		throw new BeanDefinitionStoreException(
				"Detected cyclic loading of " + encodedResource + " - check your import definitions!");
	}
	try {
		// 将资源文件转为InputStream的IO流
		InputStream inputStream = encodedResource.getResource().getInputStream();
		try {
			// 从InputStream中得到XML的解析源
			InputSource inputSource = new InputSource(inputStream);
			if (encodedResource.getEncoding() != null) {
				inputSource.setEncoding(encodedResource.getEncoding());
			}
			// 这里是具体读取过程
			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
		}
		finally {
			// 关闭流
			inputStream.close();
		}
	}
	catch (IOException ex) {
		throw new BeanDefinitionStoreException(
				"IOException parsing XML document from " + encodedResource.getResource(), ex);
	}
	finally {
		currentResources.remove(encodedResource);
		if (currentResources.isEmpty()) {
			this.resourcesCurrentlyBeingLoaded.remove();
		}
	}
}


/**
 * Actually load bean definitions from the specified XML file.
 * @param inputSource the SAX InputSource to read from
 * @param resource the resource descriptor for the XML file
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of loading or parsing errors
 * @see #doLoadDocument
 * @see #registerBeanDefinitions
 */
// 从特定xml文件中实际载入bean配置资源的方法
protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
		throws BeanDefinitionStoreException {
	try {
		// 将XML文件转换为DOM对象，解析过程有documentLoader实现
		Document doc = doLoadDocument(inputSource, resource);
		// 这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的bean配置规则
		return registerBeanDefinitions(doc, resource);
	}
	catch (BeanDefinitionStoreException ex) {
		throw ex;
	}
	catch (SAXParseException ex) {
		throw new XmlBeanDefinitionStoreException(resource.getDescription(),
				"Line " + ex.getLineNumber() + " in XML document from " + resource + " is invalid", ex);
	}
	catch (SAXException ex) {
		throw new XmlBeanDefinitionStoreException(resource.getDescription(),
				"XML document from " + resource + " is invalid", ex);
	}
	catch (ParserConfigurationException ex) {
		throw new BeanDefinitionStoreException(resource.getDescription(),
				"Parser configuration exception parsing XML from " + resource, ex);
	}
	catch (IOException ex) {
		throw new BeanDefinitionStoreException(resource.getDescription(),
				"IOException parsing XML document from " + resource, ex);
	}
	catch (Throwable ex) {
		throw new BeanDefinitionStoreException(resource.getDescription(),
				"Unexpected exception parsing XML document from " + resource, ex);
	}
}

/**
 * Actually load the specified document using the configured DocumentLoader.
 * @param inputSource the SAX InputSource to read from
 * @param resource the resource descriptor for the XML file
 * @return the DOM Document
 * @throws Exception when thrown from the DocumentLoader
 * @see #setDocumentLoader
 * @see DocumentLoader#loadDocument
 */
protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
			getValidationModeForResource(resource), isNamespaceAware());
}

```
通过源码分析，载入Bean配置信息的最后一步是将Bean配置信息转换为Document对象，该过程由documentLoader()方法实现。

### 9、准备文档对象

DocumentLoader将Bean配置资源转换成Document对象的源码如下：

```
/**
 * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
 * XML parser.
 */
// 使用标准的JAXP将载入的Bean配置资源转换成Document对象
@Override
public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
		ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {
	// 创建文件解析器工厂
	DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
	if (logger.isDebugEnabled()) {
		logger.debug("Using JAXP provider [" + factory.getClass().getName() + "]");
	}
	// 创建文档解析器
	DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
	// 解析Spring的bean配置资源
	return builder.parse(inputSource);
}

/**
 * Create the {@link DocumentBuilderFactory} instance.
 * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD}
 * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD})
 * @param namespaceAware whether the returned factory is to provide support for XML namespaces
 * @return the JAXP DocumentBuilderFactory
 * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory
 */
protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
		throws ParserConfigurationException {

	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	factory.setNamespaceAware(namespaceAware);

	if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
		factory.setValidating(true);
		if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
			// Enforce namespace aware for XSD...
			factory.setNamespaceAware(true);
			try {
				factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
			}
			catch (IllegalArgumentException ex) {
				ParserConfigurationException pcex = new ParserConfigurationException(
						"Unable to validate using XSD: Your JAXP provider [" + factory +
						"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " +
						"Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");
				pcex.initCause(ex);
				throw pcex;
			}
		}
	}

	return factory;
}
```
上面的解析过程是调用JavaEE标准的JAXP标准进行处理。至此Spring IOC容器根据定位的Bean配置信息，将其加载读入并转换成为Document对象过程完成。接下来我们要继续分析Spring IOC容器将载入的Bean配置信息转换为Document对象之后，是如何将其解析为Spring IOC管理的Bean对象并将其注册到容器中的。

### 10、分配解析策略

Xm1BeanDefinitionReader类中的doLoadBeanDefinition()方法是从特定XML文件中实际载入Bean配置资源的方法，该方法在载入Bean配置资源之后将其转换为Document对象，接下来调用registerBeanpefinitions()启动Spring IoC容器对Bean定义的解析过程，registerBeanDefinitions()方法源码如下：

```
/**
 * Register the bean definitions contained in the given DOM document.
 * Called by {@code loadBeanDefinitions}.
 * <p>Creates a new instance of the parser class and invokes
 * {@code registerBeanDefinitions} on it.
 * @param doc the DOM document
 * @param resource the resource descriptor (for context information)
 * @return the number of bean definitions found
 * @throws BeanDefinitionStoreException in case of parsing errors
 * @see #loadBeanDefinitions
 * @see #setDocumentReaderClass
 * @see BeanDefinitionDocumentReader#registerBeanDefinitions
 */
// 按照spring的bean语义要求将bean配置资源解析并转换为容器内部数据结构
public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
	// 得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析
	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
	// 获得容器中注册的bean数量
	int countBefore = getRegistry().getBeanDefinitionCount();
	// 解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，
	// 具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成
	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
	// 统计解析的bean数量
	return getRegistry().getBeanDefinitionCount() - countBefore;
}
```
Bean配置资源的载入解析分为以下两个过程：

首先，通过调用XML解析器将Bean配置信息转换得到Document对象，但是这些Document对象并没有按照Spring的Bean规则进行解析。这一步是载入的过程其次，在完成通用的XML解析之后，按照 Spring Bean的定义规则对Document对象进行解析，其解析过程是在接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader中实现。

### 11、将配置载入内存

BeanDefinitionDocumentReader 接口通过registerBeanDefinitions()方法调用其实现类DefaultBeanDefinitionDocumentReader对Document 对象进行解析，解析的代码如下：

```
/**
 * This implementation parses bean definitions according to the "spring-beans" XSD
 * (or DTD, historically).
 * <p>Opens a DOM Document; then initializes the default settings
 * specified at the {@code <beans/>} level; then parses the contained bean definitions.
 */
// 根据SpringDTD对Bean的定义规则解析Bean定义Document对象
@Override
public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
	// 获得XML描述符
	this.readerContext = readerContext;
	logger.debug("Loading bean definitions");
	// 获得Document的根元素
	Element root = doc.getDocumentElement();
	doRegisterBeanDefinitions(root);
}
/**
 * Register each bean definition within the given root {@code <beans/>} element.
 */
protected void doRegisterBeanDefinitions(Element root) {
	// Any nested <beans> elements will cause recursion in this method. In
	// order to propagate and preserve <beans> default-* attributes correctly,
	// keep track of the current (parent) delegate, which may be null. Create
	// the new (child) delegate with a reference to the parent for fallback purposes,
	// then ultimately reset this.delegate back to its original (parent) reference.
	// this behavior emulates a stack of delegates without actually necessitating one.
	// 具体的解析过程由BeanDefinitionParserDelegate实现
	// BeanDfinitionParserDelegate中定义了SpringBean定义XML文件的各种元素
	BeanDefinitionParserDelegate parent = this.delegate;
	this.delegate = createDelegate(getReaderContext(), root, parent);

	if (this.delegate.isDefaultNamespace(root)) {
		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
		if (StringUtils.hasText(profileSpec)) {
			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
				if (logger.isInfoEnabled()) {
					logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec +
							"] not matching: " + getReaderContext().getResource());
				}
				return;
			}
		}
	}
	// 在解析bean定义之前，进行自定义的解析，增强解析过程的可拓展性
	preProcessXml(root);
	// 从Document的根元素开始进行bena定义的Document对象
	parseBeanDefinitions(root, this.delegate);
	// 在解析bena定义之后，进行自定义的解析，增加解析过程的可拓展性
	postProcessXml(root);

	this.delegate = parent;
}

// 创建BeanDefinitionParserDelegate，用于完成真正的解析过程
protected BeanDefinitionParserDelegate createDelegate(
		XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {

	BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
	// 初始化Document根元素
	delegate.initDefaults(root, parentDelegate);
	return delegate;
}

/**
 * Parse the elements at the root level in the document:
 * "import", "alias", "bean".
 * @param root the DOM root element of the document
 */
// 使用Spring的bean规则从document的根元素开始进行bean定义的document对象
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
	// 判断是否使用Spring默认的XML命名空间
	if (delegate.isDefaultNamespace(root)) {
		// 查找根元素所有子节点
		NodeList nl = root.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
			Node node = nl.item(i);
			if (node instanceof Element) {
				Element ele = (Element) node;
				// 判断是否使用spinrg默认的XML命名空间
				if (delegate.isDefaultNamespace(ele)) {
					parseDefaultElement(ele, delegate);
				}
				else {
					// 没有使用spring默认命名空间，则使用用户自定义的解析规则元素节点
					delegate.parseCustomElement(ele);
				}
			}
		}
	}
	else {
		delegate.parseCustomElement(root);
	}
}

// 使用spring的Bean规则解析Document元素节点
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
	// 如果元素节点是<Import>导入元素，进行导入解析
	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
		importBeanDefinitionResource(ele);
	}
	// 如果元素节点是<Alias>别名元素，进行别名解析
	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
		processAliasRegistration(ele);
	}
	// 如果元素是<Bean>别名元素
	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
		processBeanDefinition(ele, delegate);
	}
	// 如果是<Beans>别名元素
	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
		// recurse
		doRegisterBeanDefinitions(ele);
	}
}

/**
 * Parse an "import" element and load the bean definitions
 * from the given resource into the bean factory.
 */
// 解析<Import>导入元素，从给定的导入路径加载bean配置资源到SpringIOC容器中
protected void importBeanDefinitionResource(Element ele) {
	// 获取给定的导入元素的resource属性值
	String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
	// 如果为空，怎么直接返回
	if (!StringUtils.hasText(location)) {
		getReaderContext().error("Resource location must not be empty", ele);
		return;
	}

	// Resolve system properties: e.g. "${user.dir}"
	// 使用系统变量值解析resource属性值
	location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

	Set<Resource> actualResources = new LinkedHashSet<>(4);

	// Discover whether the location is an absolute or relative URI
	// 标识是否绝对路径
	boolean absoluteLocation = false;
	try {
		absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
	}
	catch (URISyntaxException ex) {
		// cannot convert to an URI, considering the location relative
		// unless it is the well-known Spring prefix "classpath*:"
		// 不是绝对路径，考虑到相对位置，不能转换为URI，除非它是众所周知的Spring前缀“classpath*:”
	}

	// Absolute or relative?
	if (absoluteLocation) {
		try {
			// 用绝对路径加载bean配置资源
			int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
			if (logger.isDebugEnabled()) {
				logger.debug("Imported " + importCount + " bean definitions from URL location [" + location + "]");
			}
		}
		catch (BeanDefinitionStoreException ex) {
			getReaderContext().error(
					"Failed to import bean definitions from URL location [" + location + "]", ele, ex);
		}
	}
	else {
		// No URL -> considering resource location as relative to the current file.
		// 相对路径加载
		try {
			int importCount;
			Resource relativeResource = getReaderContext().getResource().createRelative(location);
			// 封装的相对路径资源存在
			if (relativeResource.exists()) {
				// 通过 loadBeanDefinitionstons 加载Bean配置资源
				importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
				actualResources.add(relativeResource);
			}
			// 封装的相对路径资源不存在
			else {
				// 根据SpringIOC容器资源读入器的基本路径加载给定导入路径资源
				String baseLocation = getReaderContext().getResource().getURL().toString();
				importCount = getReaderContext().getReader().loadBeanDefinitions(
						StringUtils.applyRelativePath(baseLocation, location), actualResources);
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Imported " + importCount + " bean definitions from relative location [" + location + "]");
			}
		}
		catch (IOException ex) {
			getReaderContext().error("Failed to resolve current resource location", ele, ex);
		}
		catch (BeanDefinitionStoreException ex) {
			getReaderContext().error("Failed to import bean definitions from relative location [" + location + "]",
					ele, ex);
		}
	}
	Resource[] actResArray = actualResources.toArray(new Resource[0]);
	// 在解析完<Import>元素之后，发送容器导入其他资源处理完成事件
	getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
}

/**
 * Process the given alias element, registering the alias with the registry.
 */
// 导入 <Alias> 元素
protected void processAliasRegistration(Element ele) {
	// name属性值
	String name = ele.getAttribute(NAME_ATTRIBUTE);
	// alias 属性值
	String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
	boolean valid = true;
	if (!StringUtils.hasText(name)) {
		getReaderContext().error("Name must not be empty", ele);
		valid = false;
	}
	if (!StringUtils.hasText(alias)) {
		getReaderContext().error("Alias must not be empty", ele);
		valid = false;
	}
	if (valid) {
		try {
			// 向容器注入别名
			getReaderContext().getRegistry().registerAlias(name, alias);
		}
		catch (Exception ex) {
			getReaderContext().error("Failed to register alias '" + alias +
					"' for bean with name '" + name + "'", ele, ex);
		}
		getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
	}
}

/**
 * Process the given bean element, parsing the bean definition
 * and registering it with the registry.
 */
// 解析<bean>标签元素
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
	// BeanDefinitionHolder 是对BeanDefinition的封装，即Bean定义封装类
	// 对Document对象中<Bean>元素的解析由BeanDefinitionParserDelegate实现
	if (bdHolder != null) {
		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
		try {
			// Register the final decorated instance.
			// 向SpringIOC容器注册解析得到的Bean定义，这是Bean定义向IOC容器注册的入口
			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
		}
		catch (BeanDefinitionStoreException ex) {
			getReaderContext().error("Failed to register bean definition with name '" +
					bdHolder.getBeanName() + "'", ele, ex);
		}
		// Send registration event.
		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
	}
}
```
通过上述Spring IOC容器对载入的Bean定义Document解析可以看出，我们使用Spring时，在Spring 配置文件中可以使用<import>元素来导入IOC容器所需要的其他资源，Spring IOC容器在解析时会首先将指定导入的资源加载进容器中。使用<ailas>别名时，Spring IOC容器首先将别名元素所定义的别名注册到容器中。

对于既不是<import>元素，又不是<alias>元素的元素，即Spring配置文件中普通的<bean>元素的解析由BeanDefinitionParserDelegate 类的parseBeanDefinitionElement0方法来实现。这个解析的过程非常复杂，我们在mini版本的时候，就用properties文件代替了。

### 12.载入<bean>元素Bean 

配置信息中的<import>和<alias>元素解析在DefaultBeanDefinitionDocumentReader中已经完成，对Bean 配置信息中使用最多的<bean>元素交由BeanDefinitionParserDelegate来解析，其解析实现的源码如下：

```
/**
 * Parses the supplied {@code <bean>} element. May return {@code null}
 * if there were errors during parse. Errors are reported to the
 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
 */
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
	return parseBeanDefinitionElement(ele, null);
}

/**
 * Parses the supplied {@code <bean>} element. May return {@code null}
 * if there were errors during parse. Errors are reported to the
 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
 */
// 解析Bean配置信息中的Bean元素，这个方法主要处理<Bean>元素的id，name和别名属性
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
	// 获取<bean>标签的id属性值
	String id = ele.getAttribute(ID_ATTRIBUTE);
	// 获取<bean>标签的name属性值
	String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

	List<String> aliases = new ArrayList<>();
	// 将所有name属性值存放到别名中，
	// 示例： <bean name="t1,t2,t3"> 分别可以 ',; ' 三个字符分割
	if (StringUtils.hasLength(nameAttr)) {
		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
		aliases.addAll(Arrays.asList(nameArr));
	}

	String beanName = id;
	// 如果<bean>元素中没有配置id属性时，将别名中的第一个值赋值给beanName
	if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
		beanName = aliases.remove(0);
		if (logger.isDebugEnabled()) {
			logger.debug("No XML 'id' specified - using '" + beanName +
					"' as bean name and " + aliases + " as aliases");
		}
	}
	// 检查对<bean>元素所配置的id或者name的唯一性，containingBean标识<Bean>
	// 元素中是否包含子<Bean>元素
	if (containingBean == null) {
		checkNameUniqueness(beanName, aliases, ele);
	}
	// 详细对<Bean>元素中配置的beanDefinition进行解析的地方
	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
	if (beanDefinition != null) {
		if (!StringUtils.hasText(beanName)) {
			try {
				if (containingBean != null) {
					// 如果<Bean>元素中没有配置id、别名或者name，且没有包含子元素
					// <Bean> 元素，为解析的bean生成一个唯一beanName并注册
					beanName = BeanDefinitionReaderUtils.generateBeanName(
							beanDefinition, this.readerContext.getRegistry(), true);
				}
				else {
					// 如果<bean>元素中没有配置id、别名或者name，且包含子元素
					// <bean>元素，为解析的Bean使用别名向IOC容器注册
					beanName = this.readerContext.generateBeanName(beanDefinition);
					// Register an alias for the plain bean class name, if still possible,
					// if the generator returned the class name plus a suffix.
					// This is expected for Spring 1.2/2.0 backwards compatibility.
					// 为解析的Bean使用别名注册式，为了向后兼容
					// Spring1.2/2.0，给别名添加类名后缀
					String beanClassName = beanDefinition.getBeanClassName();
					if (beanClassName != null &&
							beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
							!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
						aliases.add(beanClassName);
					}
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Neither XML 'id' nor 'name' specified - " +
							"using generated bean name [" + beanName + "]");
				}
			}
			catch (Exception ex) {
				error(ex.getMessage(), ele);
				return null;
			}
		}
		String[] aliasesArray = StringUtils.toStringArray(aliases);
		return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
	}

	return null;
}

/**
 * Validate that the specified bean name and aliases have not been used already
 * within the current level of beans element nesting.
 */
protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {
	String foundName = null;

	if (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {
		foundName = beanName;
	}
	if (foundName == null) {
		foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);
	}
	if (foundName != null) {
		error("Bean name '" + foundName + "' is already used in this <beans> element", beanElement);
	}

	this.usedNames.add(beanName);
	this.usedNames.addAll(aliases);
}

/**
 * Parse the bean definition itself, without regard to name or aliases. May return
 * {@code null} if problems occurred during the parsing of the bean definition.
 */
// 详细对<Bean>元素中配置的Bean定义进行解析的地方
// 由于上面的方法中已经对Bean的id、name和别名等属性进行了处理
// 该方法中主要处理这三个以外的其他属性数据
@Nullable
public AbstractBeanDefinition parseBeanDefinitionElement(
		Element ele, String beanName, @Nullable BeanDefinition containingBean) {
	// 缓存已经解析过的<Bean>
	this.parseState.push(new BeanEntry(beanName));

	// 获取<bean>元素中class属性,然后载入到BeanDefinition中去
	// 只是记录配置的class名称，不错实例化，对象的实例化在依赖注入时完成
	String className = null;
	if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
	}
	// 获取<bean>元素中parent属性
	String parent = null;
	if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
		parent = ele.getAttribute(PARENT_ATTRIBUTE);
	}

	try {
		// 根据<Bean>元素配置的class名称和parent属性值创建BeanDefinition
		// 为加载Bean定义信息做准备
		AbstractBeanDefinition bd = createBeanDefinition(className, parent);
		// 解析Bean的基本属性，是否单例(singleton)、是否抽象类、是否懒加载等等
		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
		// 为<Bean>元素解析的Bean设置description信息
		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

		// 对<bean>元素的meta(元信息)属性解析
		parseMetaElements(ele, bd);
		// 对<bean>元素的lookup-Method属性解析
		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
		// 对<Bean>元素的replaced-Method属性解析
		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

		// 解析<Bean>元素的构造方法设置
		parseConstructorArgElements(ele, bd);
		// 解析<Bean>元素的<property>设置
		parsePropertyElements(ele, bd);
		// 解析<Bean>元素的qualifier设置
		parseQualifierElements(ele, bd);

		// 为当前解析的Bean设置所需的资源和依赖对象
		bd.setResource(this.readerContext.getResource());
		bd.setSource(extractSource(ele));

		return bd;
	}
	catch (ClassNotFoundException ex) {
		error("Bean class [" + className + "] not found", ele, ex);
	}
	catch (NoClassDefFoundError err) {
		error("Class that bean class [" + className + "] depends on not found", ele, err);
	}
	catch (Throwable ex) {
		error("Unexpected failure during bean definition parsing", ele, ex);
	}
	finally {
		this.parseState.pop();
	}

	return null;
}
```
只要使用过Spring对Spring配置文件比较熟悉的人通过对上述源码的分析就会明白我们在Spring配置文件中<Bean>元素的中配置的属性就是通过该方法解析和设置到Bean中去的。

注意：在解析<Bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition，将<Bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象。

上面方法中一些对一些配置如元信息（meta）、qualifier等的解析，我们在Spring中配置时使用的也不多，我们在使用Spring的<Bean>元索时，配置最多的是<property>属性，因此我们下面继续分析源码，了解Bean的属性在解析时是如何设置的。

### 13.载入<property>元素

BeanDefinitionParserDelegate 在解析<Bean>调用parsePropertyElements0方法解析<Bean>元索中的<property>属性子元素，解析源码如下：

```
/**
 * Parse property sub-elements of the given bean element.
 */
// 解析<Bean>元素的<property>子元素
public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
	// 获取<Bean>元素中所有的子元素
	NodeList nl = beanEle.getChildNodes();
	for (int i = 0; i < nl.getLength(); i++) {
		Node node = nl.item(i);
		// 如果子元素是<property>子元素，则调用解析<property>子元素方法解析
		if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {
			parsePropertyElement((Element) node, bd);
		}
	}
}

/**
 * Parse a property element.
 */
// 解析<property>子元素
public void parsePropertyElement(Element ele, BeanDefinition bd) {
	// 获取<property>子元素的name属性
	String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
	if (!StringUtils.hasLength(propertyName)) {
		error("Tag 'property' must have a 'name' attribute", ele);
		return;
	}
	this.parseState.push(new PropertyEntry(propertyName));
	try {
		if (bd.getPropertyValues().contains(propertyName)) {
			error("Multiple 'property' definitions for property '" + propertyName + "'", ele);
			return;
		}
		// 解析获取property的值
		Object val = parsePropertyValue(ele, bd, propertyName);
		// 根据property的名字和值创建property实例
		PropertyValue pv = new PropertyValue(propertyName, val);
		// 解析<property>元素中<meta>子元素属性
		parseMetaElements(ele, pv);
		pv.setSource(extractSource(ele));
		bd.getPropertyValues().addPropertyValue(pv);
	}
	finally {
		this.parseState.pop();
	}
}


/**
 * Get the value of a property element. May be a list etc.
 * Also used for constructor arguments, "propertyName" being null in this case.
 */
// 解析获取property值
@Nullable
public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
	String elementName = (propertyName != null ?
			"<property> element for property '" + propertyName + "'" :
			"<constructor-arg> element");

	// Should only have one child element: ref, value, list, etc.
	// 获取<property>的所有子元素，只能是 其中一种类型：ref,value,list,etc等
	NodeList nl = ele.getChildNodes();
	Element subElement = null;
	for (int i = 0; i < nl.getLength(); i++) {
		Node node = nl.item(i);
		// 子元素不是descript和meta属性
		if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
				!nodeNameEquals(node, META_ELEMENT)) {
			// Child element is what we're looking for.
			if (subElement != null) {
				error(elementName + " must not contain more than one sub-element", ele);
			}
			else {
				// 当前<property>元素包含子元素
				subElement = (Element) node;
			}
		}
	}

	// 判断property属性值是ref还是value，不允许即是ref又是value
	boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
	boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
	if ((hasRefAttribute && hasValueAttribute) ||
			((hasRefAttribute || hasValueAttribute) && subElement != null)) {
		error(elementName +
				" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
	}
	// 如果属性是ref，创建一个ref的数据对象RuntimeBeanReference
	if (hasRefAttribute) {
		String refName = ele.getAttribute(REF_ATTRIBUTE);
		if (!StringUtils.hasText(refName)) {
			error(elementName + " contains empty 'ref' attribute", ele);
		}
		// 一个执行运行时所依赖对象的引用
		RuntimeBeanReference ref = new RuntimeBeanReference(refName);
		// 设置这个ref的数据对象是被当前的property对象所引用
		ref.setSource(extractSource(ele));
		return ref;
	}
	// 如果属性是value，创建一个value的数据对象TypedStringValue
	// 这个对象封装了value信息
	else if (hasValueAttribute) {
		// 一个持有String类型值的对象
		TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
		// 设置这个value数据对象是被当前的property对象所引用
		valueHolder.setSource(extractSource(ele));
		return valueHolder;
	}
	// 如果当前<property>元素中还有子元素
	else if (subElement != null) {
		// 解析<property>的子元素
		return parsePropertySubElement(subElement, bd);
	}
	else {
		// Neither child element nor "ref" or "value" attribute found.
		error(elementName + " must specify a ref or value", ele);
		return null;
	}
}
```
通过对上述源码的分析，我们可以了解在Spring配置文件中，<Bean>元索中<property>元素的相关配置是如何处理的：
1. ref被封装为指向依赖对象一个引用。
2. value配置都会封装成一个字符串类型的对象。
3. ref 和value 都通过“解析的数据类型属性值.setSource(extractSource(ele);"方法将属性值/用与所引用的属性关联起来。

在方法的最后对于<property>元素的子元素通过parsePropertySubElement ()方法解析，我们继续分析该方法的源码，了解其解析过程。

### 14.载入<property>的子元素

在BeanDefinitionParserDelegate 类中的parsePropertySubElement0方法对<property>中的子元 素解析，源码如下：

```
/**
 * Parse a value, ref or collection sub-element of a property or
 * constructor-arg element.
 * @param ele subelement of property element; we don't know which yet
 * @param bd the current bean definition (if any)
 * @param defaultValueType the default type (class name) for any
 * {@code <value>} tag that might be created
 */
// 解析<property>元素中ref、value或者集合等子元素
@Nullable
public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
	// 如果<property>没有使用Spring默认的命名空间，则使用用户自定义的规则解析内嵌元素
	if (!isDefaultNamespace(ele)) {
		return parseNestedCustomElement(ele, bd);
	}
	// 如果<property>子元素是<bean>，则使用解析<Bean>元素的方法解析
	else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
		BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
		if (nestedBd != null) {
			nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
		}
		return nestedBd;
	}
	// 如果<property>子元素是<ref>，<ref>中只能有一下3中属性：bean、local、parent
	else if (nodeNameEquals(ele, REF_ELEMENT)) {
		// A generic reference to any name of any bean.
		// 可以不再同一个spring配置文件中，具体参考spring对ref的配置规则
		// 获取<ref>中bean属性值
		String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
		boolean toParent = false;
		if (!StringUtils.hasLength(refName)) {
			// A reference to the id of another bean in a parent context.
			// 获取<ref>中parent属性值
			refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
			toParent = true;
			if (!StringUtils.hasLength(refName)) {
				error("'bean' or 'parent' is required for <ref> element", ele);
				return null;
			}
		}
		if (!StringUtils.hasText(refName)) {
			error("<ref> element contains empty target attribute", ele);
			return null;
		}
		// 创建ref类型数据，指向被引用的对象
		RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
		// 设置引用类型值是被当前子元素所引用
		ref.setSource(extractSource(ele));
		return ref;
	}
	// 如果<property>子元素是<idref>，使用解析iderf元素方法解析
	else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
		return parseIdRefElement(ele);
	}
	// 如果<property>子元素是<value>，使用解析value元素方法解析
	else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
		return parseValueElement(ele, defaultValueType);
	}
	// 如果<property>子元素是null，为<property>设置一个封装null值的字符串数据
	else if (nodeNameEquals(ele, NULL_ELEMENT)) {
		// It's a distinguished null value. Let's wrap it in a TypedStringValue
		// object in order to preserve the source location.
		TypedStringValue nullHolder = new TypedStringValue(null);
		nullHolder.setSource(extractSource(ele));
		return nullHolder;
	}
	// 如果<property>子元素是<array>，使用解析array元素方法解析
	else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
		return parseArrayElement(ele, bd);
	}
	// 如果<property>子元素是<list>，使用解析 list 元素方法解析
	else if (nodeNameEquals(ele, LIST_ELEMENT)) {
		return parseListElement(ele, bd);
	}
	// 如果<property>子元素是<set>，使用解析 set 元素方法解析
	else if (nodeNameEquals(ele, SET_ELEMENT)) {
		return parseSetElement(ele, bd);
	}
	// 如果<property>子元素是<map>，使用解析 map 元素方法解析
	else if (nodeNameEquals(ele, MAP_ELEMENT)) {
		return parseMapElement(ele, bd);
	}
	// 如果<property>子元素是<props>，使用解析 props 元素方法解析
	else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
		return parsePropsElement(ele);
	}
	else {
		error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);
		return null;
	}
}
```
通过上述源码分析，我们明白了在Spring配置文件中，对<property>元素中配置的array、list、set、map、prop 等各种集合子元素的都通过上述方法解析，生成对应的数据对象，比如ManagedList、ManagedArray、ManagedSet等，这些Managed类是Spring 对象BeanDefiniton的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范，一目了然，我们对<list>集合元素的解析方法进行源码分析，了解其实现过程。

### 15.载入<list>的子元素

在BeanDefinitionParserDelegate 类中的parselistElement0方法就是具体实现解析<property>元素中的<list>集合子元素，源码如下：

```
/**
 * Parse a list element.
 */
// 解析<list>集合子元素
public List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {
	// 获取<list>元素中的value-type属性，即获取集合元素的数据类型
	String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
	// 获取<list>集合元素中的所有子节点
	NodeList nl = collectionEle.getChildNodes();
	// spring中将List封装为ManagedList
	ManagedList<Object> target = new ManagedList<>(nl.getLength());
	target.setSource(extractSource(collectionEle));
	// 设置集合目标数据类型
	target.setElementTypeName(defaultElementType);
	target.setMergeEnabled(parseMergeAttribute(collectionEle));
	// 具体的<list>元素解析
	parseCollectionElements(nl, target, bd, defaultElementType);
	return target;
}

// 具体解析<list>集合元素，<array>、<list>和<set>都使用该方法解析
protected void parseCollectionElements(
		NodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {
	// 遍历集合所有节点
	for (int i = 0; i < elementNodes.getLength(); i++) {
		// 节点不是description节点
		Node node = elementNodes.item(i);
		if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {
			// 将解析的元素加入集合中，递归调用下一个元素
			target.add(parsePropertySubElement((Element) node, bd, defaultElementType));
		}
	}
}
```
经过对Spring Bean配置信息转换的Document对象中的元素层层解析Spring IOC现在已经将XML形式定义的Bean 配置信息转换为Spring IOC所识别的数据结构——BeanDefinition，它是Bean配置信息中配置的POJO对象在Spring IOC容器中的映射，我们可以通过AbstractBeanDefinition为入口，看到了IOC容器进行索引、查询和操作。

通过Spring IOC容器对Bean配置资源的解析后，IOC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IOC容器中BeanDefinition存储的只是一些静态信息，接下来需要向容器注册Bean定义信息才能全部完成IOC容器的初始化过程

### 16.分配注册策略

让我们继续跟踪程序的执行顺序，接下来我们来分析DefaultBeanDefinitionDocumentReader对Bean 定义转换的Document 对象解析的流程中，在其parseDefaultElement0方法中完成对Document 对象的解析后得到封装BeanDefinition的BeanDefinitionHold 对象，然后调用BeanDefinitionReaderUtils的registerBeanDefinition()方法向IOC容器注册解析的Bean，BeanDefinitionReaderUtils的注册的源码如下：

```
/**
 * Register the given bean definition with the given bean factory.
 * @param definitionHolder the bean definition including name and aliases
 * @param registry the bean factory to register with
 * @throws BeanDefinitionStoreException if registration failed
 */
// 将解析的BeanDefinitionHold注册到容器中
public static void registerBeanDefinition(
		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
		throws BeanDefinitionStoreException {

	// Register bean definition under primary name.
	// 获取解析的BeanDefinition的名称
	String beanName = definitionHolder.getBeanName();
	// 向IOC容器注册BeanDefinition
	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

	// Register aliases for bean name, if any.
	// 如果解析的BeanDefinition有别名，容器为期注册别名
	String[] aliases = definitionHolder.getAliases();
	if (aliases != null) {
		for (String alias : aliases) {
			registry.registerAlias(beanName, alias);
		}
	}
}
```
当调用BeanDefinitionReaderUtils向IOC 容器注册解析的BeanDefinition时，真正完成注册功能的 是DefaultListableBeanFactory。

### 17.向容器注册 

DefaultListableBeanFactory 中使用一个HashMap的集合对象存放IOC容器中注册解析的 BeanDefinition，向IOC容器注册的主要源码如下：

![image](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Spring/Spring_2020-08-09_22-25-06.jpg)


```
/** Map of bean definition objects, keyed by bean name */
// 存储注册信息的BeanDefinition
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);


//---------------------------------------------------------------------
// Implementation of BeanDefinitionRegistry interface
//---------------------------------------------------------------------
// 向IOC容器注册解析BeanDefinition
@Override
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
		throws BeanDefinitionStoreException {

	Assert.hasText(beanName, "Bean name must not be empty");
	Assert.notNull(beanDefinition, "BeanDefinition must not be null");
	// 校验解析的BeanDefinition
	if (beanDefinition instanceof AbstractBeanDefinition) {
		try {
			((AbstractBeanDefinition) beanDefinition).validate();
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
					"Validation of bean definition failed", ex);
		}
	}

	BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
	if (existingDefinition != null) {
		if (!isAllowBeanDefinitionOverriding()) {
			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
					"Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
					"': There is already [" + existingDefinition + "] bound.");
		}
		else if (existingDefinition.getRole() < beanDefinition.getRole()) {
			// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
			if (logger.isWarnEnabled()) {
				logger.warn("Overriding user-defined bean definition for bean '" + beanName +
						"' with a framework-generated bean definition: replacing [" +
						existingDefinition + "] with [" + beanDefinition + "]");
			}
		}
		else if (!beanDefinition.equals(existingDefinition)) {
			if (logger.isInfoEnabled()) {
				logger.info("Overriding bean definition for bean '" + beanName +
						"' with a different definition: replacing [" + existingDefinition +
						"] with [" + beanDefinition + "]");
			}
		}
		else {
			if (logger.isDebugEnabled()) {
				logger.debug("Overriding bean definition for bean '" + beanName +
						"' with an equivalent definition: replacing [" + existingDefinition +
						"] with [" + beanDefinition + "]");
			}
		}
		this.beanDefinitionMap.put(beanName, beanDefinition);
	}
	else {
		if (hasBeanCreationStarted()) {
			// Cannot modify startup-time collection elements anymore (for stable iteration)
			// 注册的过程中需要线程同步，以保证数据的一致性
			synchronized (this.beanDefinitionMap) {
				this.beanDefinitionMap.put(beanName, beanDefinition);
				List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
				updatedDefinitions.addAll(this.beanDefinitionNames);
				updatedDefinitions.add(beanName);
				this.beanDefinitionNames = updatedDefinitions;
				if (this.manualSingletonNames.contains(beanName)) {
					Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);
					updatedSingletons.remove(beanName);
					this.manualSingletonNames = updatedSingletons;
				}
			}
		}
		else {
			// Still in startup registration phase
			this.beanDefinitionMap.put(beanName, beanDefinition);
			this.beanDefinitionNames.add(beanName);
			this.manualSingletonNames.remove(beanName);
		}
		this.frozenBeanDefinitionNames = null;
	}
	// 检查是否有同名的BeanDefinition已经在IOC容器中注册
	if (existingDefinition != null || containsSingleton(beanName)) {
		// 重置所有已经注册过的BeanDefinition的缓存
		resetBeanDefinition(beanName);
	}
	else if (isConfigurationFrozen()) {
		clearByTypeCache();
	}
}

```
至此，Bean 配置信息中配置的Bean 被解析过后，已经注册到IOC容器中，被容器管理起来，真正完成了IOC容器初始化所做的全部工作。现在IOC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IOC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IOC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。

