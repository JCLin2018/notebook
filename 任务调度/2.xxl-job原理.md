# XXL-JOB原理

## 1.xxl-job基本介绍

xxl-job的调度原理：调度线程在一个while循环中不断地获取一定数量的即将触发的Trigger， 拿到绑定的Job， 包装成工作线程执行。

当然，不管在任何调度系统中，底层都是线程模型。如果要自己写一个调度系统，一定要对多线程并发这一块有比较深入的学习， 比如线程怎么启动怎么wait怎么notify怎么加锁等等。

### 1.2.Quartz的不足

Quartz有差不多20年的历史， 调度模型已经非常成熟了，而且很容易集成到Spring中去， 用来执行业务任务是一个很好的选择。

但是还是会有一些问题，比如：

1. 调度逻辑(Scheduler) 和任务类耦合在同一个项目中， 随着调度任务数量逐渐增多，同时调度任务逻辑逐渐加重，调度系统的整体性能会受到很大的影响；
2. Quartz集群的节点之间负载结果是随机的， 谁抢到了数据库锁就由谁去执行任务，这就有可能出现旱的旱死，涝的涝死的情况，发挥不了机器的性能。
3. Quartz本身没有提供动态调度和管理界面的功能， 需要自己根据API进行开发。
4. Quartz的日志记录、数据统计、监控不是特别完善。

xxl-job和Elastic-Job都是对Quartz进行了封装， 让我们用起来更简单， 功能更强大。在是否需要重新造轮子这一件事情上面，大家的看法是一致的。

### 1.3.xxl-job发展历史

源码地址：https://github.com/xuxueli/xxl-job
中文文档：https://www.xuxuelicom/xxl-job/

2015年开源，一个大众点评的程序员的业余之作。众所周知，大众点评因为被美团收购了，现在是美团点评。

xxl是作者名字许雪里的首字母简写， 除了xxl-job之外，作者还开源了很多其他组件， 现在一共有11个开源项目， 组成了xxl家族。

到目前为止登记使用xxl-job的公司有几百家， 算上那些没有登记的公司， 实际上应该有几千家不止。

在xxl-job早期的版本中， 直接使用了Quartz的调度模型， 直到2019年7月7日发布的7.27版本才移除Quartz依赖。

实际上即使重构代码移除了Quartz的依赖， xxl-job中也到处是Quartz的影子。比如任务、调度器、触发器的三个维度设计，是非常经典的。

xxl-job弱化了触发器的概念， 统一用cron触发， 获取任务的流程给Quartz是类似的。


### 1.4xxl-job特性

跟老牌的Quartz相比，xxl-job拥有更加丰富的功能。

总体上可以分为三类：

1. 性能提升：可以调度更多任务
2. 可靠性的提升，任务超时、失败、故障转移的处理
3. 运维更加便捷：提供操作界面、有用户权限、详细的日志、提供通知配置、自动生成报表等等。

## 2.xxl-job快速上手

源码：https://github.com/xuxueli/xxl-job

- /doc:文档资料，包括“调度数据库”建表脚本
- /xxl-job-core:公共jar依赖
- /xxl-job-admin:调度中心，项目源码
- /xxl-job-executor-samples:执行器，sample示例项目

生成8张表

| 表名               | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| xxl_job_group      | 执行器信息表，维护任务执行器信息                             |
| xxl_job_info       | 调度扩展信息表：用于保存XXL-JOB调度任务的扩展信息， 如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等 |
| xxl_job_lock       | 任务调度锁表                                                 |
| xxl_job_log        | 调度日志表：用于保存XXL-JOB任务调度的历史信息， 如调度结果、执行结果、调度入参、调度机器和执行器等等 |
| xxl_job_log_report | 调度日志报表：用户存储XXL-JOB任务调度日志的报表， 调度中心报表功能页面会用到 |
| xxl_job_logglue    | 任务GLUE日志：用于保存GLUE更新历史， 用于支持GLUE的版本回溯功能 |
| xxl_job_registry   | 执行器注册表，维护在线的执行器和调度中心机器地址信息         |
| xxl_job_user       | 系统用户表                                                   |

这里我们先说一下总体概念。

admin和executor的项目可以单独复制出来(两个Spring Boot工程) ， 修改一下pom文件。实际上开发、运行的时候肯定也是独立的工程。

这个执行器也不一定是单独运行的，可能会集成在业务项目里面(多启动一个端口)，所以还有一个名字叫业务实例。

xxl-job的调度器和业务执行是独立的。调度器决定任务的调度， 并且通过HTTP的方式调用执行器接口执行任务。

![image-20210424153710659](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210424153710.png)

所以这里我们需要先配置至少一个调度中心，运行起来，也可以集群部署。

然后在配置至少一个执行器，运行起来，同样可以集群部署。

启动顺序是县启动调度器，再启动执行器。



### 2.1.配置调度中心

调度中心是任务的指挥中心，可以有多个实例。

核心依赖：xxl-job-core

#### 配置

```properties
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asiz/Shanghai
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

#### 添加任务

一个任务可以由多个执行器一起完成，这个就叫任务分片。

![image-20210424223756693](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210424223756.png)

##### 路由策略

路由策略是指一个任务选择哪个执行器去执行，Quartz只能随机负载。

这个参数当执行器做集群的时候才有意义。顺序是执行器注册的顺序。

xxl-job提供了丰富的路由策略，包括：

| 策略           | 参数值                | 详细含义                                                     |
| -------------- | --------------------- | ------------------------------------------------------------ |
| 第一个         | FIRST                 | 固定选择第一个机器                                           |
| 最后一个       | LAST                  | 固定选择最后一个机器                                         |
| 轮询           | ROUND                 | 依次选择执行                                                 |
| 随机           | RANDOM                | 随机选择在线的机器                                           |
| 一致性HASH     | CONSISTENT_HASH       | 每个任务按照Hash算法固定选择某一台机器， 且所有任务均匀散列在不同机器上 |
| 最不经常使用   | LEAST_FREQUENTLY_USED | 使用频率最低的机器优先被选举                                 |
| 最近最久未使用 | LEAST_RECENTLY_USED   | 最久未使用的机器优先被选举                                   |
| 故障转移       | FAILOVER              | 按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目   |
| 忙碌转移       | BUSYOVER              | 按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度 |
| 分片广播       | SHARDING_BROADCAST    | 广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。 |

##### 运行模式

- BEAN模式

  需要指定任务类，这个任务类叫做JobHandler，是在执行器端编写的。

- GLUE模式

  运行代码或者脚本，支持Java、Shell、Python、PHP、Node.js、PowerShell，这个代码是直接在调度器维护。

前段时间阿里云、腾讯云各种云报XXL-JOB的远程执行漏洞，说的就是这个，如果吧服务部署在外网，而且没有做鉴权，就有很大风险。

其实也不算漏洞，只要在执行器和调度中心配置相同的token就ok

```properties
xxl.job.accessToken=
```

##### 阻塞处理策略

是指任务的一次运行还没结束的时候，下一次调度的时间又到了，这个时候怎么处理。

1. SERIAL_EXECUTION(单机串行， 默认)：对当前线程不做任何处理，并在当前线程的队列里增加一个执行任务(一次只执行一个任务)。
   举例：有个任务是增加访问计数。虽然上次任务还没执行完，但是计数还是要增加，所以先放到队列里面。
2. DISCARD LATER(丢弃后续调度)：如果当前线程阻塞，后续任务不再执行，直接返回失败(阻塞就不再执行了)。
   举例：有个任务是清理日志，上次还没执行完，但是不需要重复清理，忽略。
3. COVER EARLY(覆盖之前调度) ：创建一个移除原因， 新建一个线程去执行后续任务(杀掉当前线程)。
   举例：有个任务是下载文件，如果上次还没跑完，可能是出问题了，直接停掉重新下载。

##### 子任务

在一个任务的末尾触发另一个任务，如果我们需要在本任务执行结束并且执行成功的时候触发另一个任务，那么就可以吧另一个任务作为本任务的子任务运行。

因为每一个任务都拥有一个唯一的任务ID（任务ID可以从任务列表获取），只需要把JobId填上就可以了。



## 3.xxl-job任务详解

### 1.开发步骤

所有的任务开发流程都是一样的，以普通任务为例：
com.xx.job.executor.service.job handler.Simple Job Handler

```java
@Xxl Job("demo Job Handler")
public ReturnT<String>demoJobHandler(String param) throws Exception{
  // 打印日志的标准方式
  XxlJobLogger.log("myjob，HelloWorld.");
  // 模拟业务执行
  for(int i=0;i<5;i++) {
    XxlJobLogger.log("qing shan job beat at："+i);
    TimeUnit.SECONDS.sleep(2);
  }
  // 返回执行结果
  return ReturnT.SUCCESS;
}
```

1. 在Spring Bean实例中(@Component注解) ， 开发Job方法。方式格式要求为"public Return T<String>execute(String param) "。

   返回值和参数格式是固定。因为调度器要知道调度结果，必须统一返回格式。参数格式其实是添加任务的时候最下面的那个框，都是输入字符。

   方法名可以自定义。

2. 注解

   为Job方法添加注解@Xxl Job注解。

   这里面有几个属性， 第一个value值对应的是调度中心新建任务的JobHandler属性的值。另外的init对应JobHandler初始化方法， destroy对应JobHandler销毁方法。

   这两个方法要在任务类里面创建。

3. 执行日志：需要通过“XxlJobLogger.log”打印执行日志，会写到指定的日志文件中。

   这个是固定规范，任何任务的开发毒药遵循这个流程，就跟Quartz的任务必须实现Job接口一样

### 2.任务类别

#### 普通任务

没什么好讲。。。。

#### 分片任务

为什么需要分片任务?

假设有一个任务需要处理20万条数据，每条数据的业务逻辑处理要0.1秒。对于普通任务的来说，只有一个线程来处理，差不多5.5个小时才能处理完。

这个效率实在是太低了。怎么提升数据的处理效率呢?

当然可以在这个任务里面创建很多个线程，然后大家各自查一段数据，同时处理。比如创建4个线程，每个线程查询的ID范围不同，或者查询的日期范围不同，同时处理数据。

但是这种做法并没有真正地实现负载，这4个线程占用的是同一台机器的资源。而有可能我们的执行器做了集群部署，其他的节点是空闲的。出现了旱的旱死，涝的涝死的情况。

那问题就来了，一个大数据量的任务，我可以让一个执行器各处理一部分，一起完成么?

这个就叫做任务分片，实际上这个时候占用了三个执行器各自一个线程。

注意这里要明确一个概念，这个实际上是数据分片而不是任务分片。不是把一个任务拆成了三个步骤，一人做一个步骤。而是把一个任务交给三个执行器共同完成。

这三个执行器做的是同一件事情，但是没有依赖关系。

分片怎么实现呢?用xxl-job的分片任务就可以很容易地实现。

打个比方。现在有一个任务是“搬完1000块砖头”，我们有三个搬砖小组(三个执行器)。

如果是普通任务，其中有一个小组会派一个打工人出来搬砖，他一个人要搬完1000块砖头。

![image-20210424231743695](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210424231743.png)

如果是分片广播任务，三个搬砖小组毒药执行这个“搬完1000块砖”的任务，每个小组都要派一个人出来，3个人要共同完成这个任务。

![image-20210424231756251](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210424231756.png)

所以，分片广播任务是在所有的执行器上都运行一个任务。

如果运行的是相同的任务，执行同一段代码，不会有冲突吗?

注意，分片任务在运行的时候，调度器会给每个执行器发送一个不同的分片序号。分片的最大序号跟执行器的总数量是一样的，确保每个执行器都会执行到这个任务，而且每个人拿到的分片序号是不同的。比如我们有三个执行器。第一个执行器拿到的分片序号是0，第二个执行器拿到的分片序号是1，第三个执行器拿到的序号是2。

拿到分片序号之后怎么实现分片呢?这个就简单咯。假设这1000块砖头是有编号
的：

- 编号%3，余数是0的，在第1个执行器执行；
- 编号%3，余数是1的，在第2个执行器执行；
- 编号%3，余数是2的，在第3个执行器执行。

我们获取数据的SQL可以这样写：

```sql
SELECT id， name， password
FROM t_prod cut
WHERE status= 0
AND mod(id,#{count})=#{index}   -- count分片总数，index当前分片数
order by id desc
LIMIT 1000
```

实际的做法：可以为这张表专门创建一个分片字段，就不用取模导致索引失效了。

在Elastic-Job里面， 这个分片参数(sharding-param) 是可以自定义的， 比如你可以传0、1、2， 也可以传2018、2019、2020， 也可以传red、blue、yellow。

其实分片参数只是每个节点用来过滤数据的条件而已。

因为所有的执行器都是平等的，其实你不用关心哪个执行器拿到什么序号，哪些数据在哪个执行器处理，只要保证每个执行器根据分片序号，处理了不同的数据就OK了，也不一定是完全均等的数据量，取模只是举例。

我们也可以把0、1、2替换成其他条件去从所有数据中获取部分数据。比如：分片序号是0，我就查2018年的数据，分片序号是1，我就查2019年的数据......

## 4.xxl-job架构设计

xxl-job跟quartz特性和部署方式的不同，本质上是因为架构设计的不同。

### 1.系统组成

![image-20210424232556363](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210424232557.png)

整体上划分两个模块：

#### 1.1.调度模块（调度中心）

负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；

调度中心支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等， 所有上述操作都会实时生效， 同时支持监控调度结果以及执行日志， 支持执行器Failover。

#### 1.2.执行模块（执行器）

负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；

接收“调度中心”的执行请求、终止请求和日志请求等。

从整体来看， xxl-job架构依赖较少， 功能强大， 简约而不简单， 方便部署， 易于使用。

### 2.设计思想

#### 2.1.调度与任务解耦

在Quartz中， 调度逻辑和任务代码是耦合在一个项目中的。项目经理和小组组长、打工人们是挤在一间办公室的。

而xxl-job把调度的动作抽象和独立出来， 形成“调度中心”公共平台。调度中心只负责发起调度请求，平台自身并不承担业务逻辑。项目经理有了独立的办公室，通过电话安排任务。

将任务抽象成分散的Job Handler， 交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的Job Handler中业务逻辑。可以有几个小组组长(搬砖一组， 搬砖二组，搬砖三组)，他们会找打工人执行任务。

为什么要这样设计呢?

“调度”和“任务”两部分相互解耦，可以提高系统整体稳定性和扩展性。

项目经理跟搬砖小组不是一个整体，都是可以被替代的，也可以各自有自己的集群。

#### 2.2.全异步化、轻量级

Quartz原来的设计是这样的：在一个while循环里面， 不断地获取下一个即将触发的任务，包装成一个线程执行它。任务的执行是不会占用调度线程的时间的，但是任务的触发会占用调度线程的时间，也就是获取任务、创建线程的时间。

xxl-job把调度器和任务执行解耦以后， 把触发的过程改成了异步的触发，它会先把调度请求放进一个“异步调度队列”。任务的执行不消耗调度中心的资源，它的结果也是异步返回的。

根据官方的描述，单个任务的一次运行平均耗时基本在“10ms”之内(基本为一次请求的网络开销)，所以即使线程数量有限，也不会影响任务的执行。

异步执行：执行器会将请求存入“异步执行队列”并且立即响应调度中心，异步运行。

所以经过优化之后，理论上默认配置下的调度中心，单机能够支撑5000任务并发运行稳定运行。

实际场景中， 由于调度中心与执行器网络ping延迟不同、DB读写耗时不同、任务调度密集程度不同，会导致任务量上限会上下波动。

如若需要支撑更多的任务量， 可以通过调大调度线程数、降低调度中心与执行器ping延迟和提升机器配置几种方式优化。

#### 2.3.均衡调度

调度中心在集群部署时会自动进行任务平均分配，触发组件每次获取与线程池数量(调度中心支持自定义调度线程池大小)相关数量的任务，避免大量任务集中在单个调度中心集群节点。

调度器：

```properties
xxl.job.triggerpool.fast.max= 200
xxl.job.triggerpool.slow.max= 100
```



## 5.原理分析

因为调度的流程涉及到执行器，所以我们先分析执行器。

执行器启动主要做的事情：把自己注册到调度中心，保存在数据库。

### 1.执行器启动与注册

















