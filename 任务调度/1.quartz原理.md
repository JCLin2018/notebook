# 一文简单阐述Quartz原理

## 简介

[Quartz官网](https://www.quartz-scheduler.org/)

[Quartz-github](https://github.com/quartz-scheduler/quartz)

Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的[Java组件](https://baike.baidu.com/item/Java组件/53178233)或 EJBs。Quartz的最新版本为Quartz 2.3.2。

特点：

- 精确到毫秒级别的调度
- 可以独立运行，可以集成到容器中
- 支持事务（JobStoreCMT）
- 支持集群
- 支持持久化

## 简单JavaDemo

```java
public class MyScheduler {
    public static void main(String[] args) throws SchedulerException, InterruptedException {
        // 1、创建调度器Scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容)
        JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)
                                        .withIdentity("job1", "group1").build();
        // 3、构建Trigger实例,每隔1s执行一次
        Trigger trigger = TriggerBuilder.newTrigger().withIdentity("trigger1", "triggerGroup1")
                .startNow() // 立即生效
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1) // 每隔1s执行一次
                .repeatForever()).build(); // 一直执行
        // 4、执行
        scheduler.scheduleJob(jobDetail, trigger);
        System.out.println("--------scheduler start ! ------------");
        scheduler.start();
        // 睡眠
        TimeUnit.MINUTES.sleep(1);
        scheduler.shutdown();
        System.out.println("--------scheduler shutdown ! ------------");
    }
  	
  	class PrintWordsJob implements Job {
      	@Override
        public void execute(JobExecutionContext context) throws JobExecutionException {
            System.out.println("-------- 执行 --------");
        }
    }
}
```



![image-20210415230645319](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210415230844.png)

## JobDetail

我们创建一个实现Job接口的类，使用JobBuilder包装成JobDetail，它可以携带key、value的数据

## Trigger

定义任务的触发规律，Trigger使用TriggerBuilder来构建

| 子接口                   | 描述                 | 特点                                                         |
| ------------------------ | -------------------- | ------------------------------------------------------------ |
| SimpleTrigger            | 简单触发器           | 固定时刻或者时间间隔，毫秒                                   |
| CalendarIntervalTrigger  | 基与日历触发器       | 比简单触发器更多时间单位，支持非固定时间的触发，例如一年可能365/366，一个月肯呢个28/29/30/31 |
| DailyTimeIntervalTrigger | 基于日历触发器       | 每天的某一个时段                                             |
| CronTrigger              | 基与Cron表达式触发器 |                                                              |

![image-20210421230958371](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210421230959.png)

### 基于Calendar的排除规则

如果要在触发器的基础上，排除一些时间不执行任务，就要用到Quartz的Calendar类（不是JDK的Calendar）。可以按年、月、周、日、特定日期、Cron表达式排除。

![image-20210421231419519](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210421231419.png)

调用Trigger的modifiedByCalendar()添加到触发器中，并且调用调度器的addCalendar()方法注册排除规则。

| Calendar名称    | 用法                                                         |
| --------------- | ------------------------------------------------------------ |
| BaseClendar     | 顶级的Calendar实现基本功能                                   |
| AnnualCalendar  | 排除一年中的一天或者多天                                     |
| CronCalendar    |                                                              |
| DailyCalendar   | 每个DailyCalendar仅允许指定单个时间范围，并且改时间范围可能不会跨越每日边界（不能指定从下午8点至凌晨5点的时间范围）。 |
| HolidayCalendar | 特别的用于从Trigger中排除节假日                              |
| MonthlyCalendar | 排除月份中的指定数天，例如，可用于排除每月的最后一天         |
| WeeklyCalendar  | 排除星期中的任意周几，例如，可用于排除周末，默认周六日       |

```java
public static void main(String[] args) throws Exception {
  SchedulerFactory sf = new StdSchedulerFactory();
  Scheduler scheduler = sf.getScheduler();
  scheduler.start();

  // 定义日历
  AnnualCalendar holidays = new AnnualCalendar();

  // 排除圣诞节
  Calendar christmas = new GregorianCalendar(2021, 12, 25);
  holidays.setDayExcluded(christmas, true);

  // 调度器添加日历
  scheduler.addCalendar("holidays", holidays, false, false);

  JobDetail jobDetail = JobBuilder.newJob(MyJob1.class)
    .withIdentity("job1", "group1")
    .usingJobData("test","test1")
    .build();

  Trigger trigger = TriggerBuilder.newTrigger()
    .withIdentity("trigger1", "group1")
    .startNow()
    .modifiedByCalendar("holidays")
    .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                  .withIntervalInSeconds(2)
                  .repeatForever())
    .build();

  Date firstRunTime = scheduler.scheduleJob(jobDetail, trigger);
  System.out.println(jobDetail.getKey() + " 第一次触发： " + firstRunTime);
}
```

## Scheduler

调度器，是Quartz的指挥官，由StdSchedulerFactory产生。它是单例的。

并且是Quartz中最重要的API，默认是实现类是StdScheduler，里面包含了一个QuartzScheduler。QuartzScheduler里面又包含了一个QuartzSchedulerThread。



Scheduler中的方法主要分为三大类：

1. 操作调度器本身，例如调度器的启动start()、调度的关闭shutdown()
2. 操作Trigger，例如pauseTriggers()、resumeTrigger()
3. 操作job，例如scheduleJob()、unscheduleJob()、rescheduleJob()

**这些方法可以用来实现任务的动态调度。**

## Listener

LIstener利用了观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖的对象都会得到通知并自动更新。

Quartz中提供三种Listener，监听Scheduler的、监听Trigger的、监听Job的。

只需要创建类实现相应的接口，并在Scheduler上注册Listener，便可实现对核心对象的监听。

### SchedulerListener

```java
public class MySchedulerListener implements SchedulerListener {

    public void jobScheduled(Trigger trigger) {
        String jobName = trigger.getJobKey().getName();
        System.out.println(jobName + " has been scheduled");
    }

    public void jobUnscheduled(TriggerKey triggerKey) {
        System.out.println(triggerKey + " is being unscheduled");
    }

    public void triggerFinalized(Trigger trigger) {
        System.out.println("Trigger is finished for " + trigger.getJobKey().getName());
    }

    public void triggerPaused(TriggerKey triggerKey) {
        System.out.println(triggerKey + " is being paused");
    }

    public void triggersPaused(String triggerGroup) {
        System.out.println("trigger group " + triggerGroup + " is being paused");
    }

    public void triggerResumed(TriggerKey triggerKey) {
        System.out.println(triggerKey + " is being resumed");
    }

    public void triggersResumed(String triggerGroup) {
        System.out.println("trigger group " + triggerGroup + " is being resumed");
    }


    public void jobAdded(JobDetail jobDetail) {
        System.out.println(jobDetail.getKey() + " is added");
    }

    public void jobDeleted(JobKey jobKey) {
        System.out.println(jobKey + " is deleted");
    }

    public void jobPaused(JobKey jobKey) {
        System.out.println(jobKey + " is paused");
    }

    public void jobsPaused(String jobGroup) {
        System.out.println("job group " + jobGroup + " is paused");
    }

    public void jobResumed(JobKey jobKey) {
        System.out.println(jobKey + " is resumed");
    }

    public void jobsResumed(String jobGroup) {
        System.out.println("job group " + jobGroup + " is resumed");
    }

    public void schedulerError(String msg, SchedulerException cause) {
        System.out.println(msg + cause.getUnderlyingException().getStackTrace());
    }

    public void schedulerInStandbyMode() {
        System.out.println("scheduler is in standby mode");
    }

    public void schedulerStarted() {
        System.out.println("scheduler has been started");
    }

    public void schedulerStarting() {
        System.out.println("scheduler is being started");
    }

    public void schedulerShutdown() {
        System.out.println("scheduler has been shutdown");
    }

    public void schedulerShuttingdown() {
        System.out.println("scheduler is being shutdown");
    }

    public void schedulingDataCleared() {
        System.out.println("scheduler has cleared all data");
    }
}
```



### TriggerListener

```java
public class MyTriggerListener implements TriggerListener {

    // Trigger 被触发，Job 上的 execute() 方法将要被执行时
    public void triggerFired(Trigger trigger, JobExecutionContext context) {
        String triggerName = trigger.getKey().getName();
        System.out.println("Method " + triggerName + " was fired");
    }

    // 在 Trigger 触发后，Job 将要被执行时由 Scheduler 调用这个方法
    // TriggerListener给了一个选择去否决Job的执行。假如返回true时，这个任务Job不会被触发
    public boolean vetoJobExecution(Trigger trigger, JobExecutionContext context) {
        String triggerName = trigger.getKey().getName();
        System.out.println("Method " + triggerName + " was not vetoed");
        return false;
    }
	// Trigger错过触发时调用
    public void triggerMisfired(Trigger trigger) {
        String triggerName = trigger.getKey().getName();
        System.out.println("Method " + triggerName + " misfired");
    }
	// Trigger被触发并且完成了Job的执行时，Scheduler调用这个方法
    public void triggerComplete(Trigger trigger, JobExecutionContext context, Trigger.CompletedExecutionInstruction triggerInstructionCode) {
        String triggerName = trigger.getKey().getName();
        System.out.println("Method " + triggerName + " is complete");
    }
}
```



### JobListener

```java
public class MyJobListener implements JobListener {
	// 返回JobListener名称
    public String getName() {
        String name = getClass().getSimpleName();
        System.out.println("Method :" + "获取到监听器名称：" + name);
        return name;
    }
	// Scheduler 在 JobDetail 将要被执行时调用这个方法
    public void jobToBeExecuted(JobExecutionContext context) {
        String jobName = context.getJobDetail().getKey().getName();
        System.out.println("Method :" + jobName + " ——任务即将执行 ");
    }
	// Scheduler 在 JobDetail 即将被执行，但又被TriggerListener否决了 这时调用这个方法
    public void jobExecutionVetoed(JobExecutionContext context) {
        String jobName = context.getJobDetail().getKey().getName();
        System.out.println("Method :" + jobName + " ——任务被否决 ");
    }
	// Scheduler 在 JobDetail 执行之后调用
    public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) {
        String jobName = context.getJobDetail().getKey().getName();
        System.out.println("Method :" + jobName + " ——执行完毕 ");
    }
}
```

### 使用方法

```java
scheduler.getListenerManager().addJobListener(new MyJobListener(), EverythingMatcher.allJobs());
scheduler.getListenerManager().addTriggerListener(new MyTriggerListener(), EverythingMatcher.allTriggers());
scheduler.getListenerManager().addSchedulerListener(new MySchedulerListener());
```

### 工具类Matcher

主要是基于groupName和keyName进行匹配

![image-20210421234634291](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/quartz/20210421234634.png)

## JobStore

JobStore用来存储任务和触发器相关信息，例如所有任务的名称、数量、状态等。Quartz中有两种存储任务的方式，一种在内存，一种在数据库。

### RAMJobStore



### JDBCJobStore



## Quartz集成到Spring





## 动态调度的实现





## Quartz集群部署





## Quartz调度原理



