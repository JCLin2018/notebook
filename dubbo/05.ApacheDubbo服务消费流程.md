# Dubbo服务消费流程

例子：

```java
@RestController
public class SayController {
    @DubboReference(registry = {"shanghai", "hunan"},
            protocol = "dubbo",
            loadbalance = "consistenthash",
            mock = "com.sendbp.dubbo.springbootdubboconsumer.MockSayHelloService",
            timeout = 500,
            cluster = "failfast", check = false, retries = 5)
    ISayHelloService sayHelloService;
    @GetMapping("/say")
    public String say() {
        return sayHelloService.sayHello("Mic");
    }
}
```

Dubbo的服务消费者注入也有两种方式： 

- 通过xml形式 
- 基于注解的方式

## Dubbo自动装配类  DubboAutoConfiguration


基于xml方式的配置就不说了，比较简单。 我们来分析一下基于注解的方式的解析过程

- 首先会在`DubboAutoConfiguration`中配置一个自动装配机制

```java

@ConditionalOnProperty(prefix = DUBBO_PREFIX, name = "enabled", matchIfMissing = true)
@Configuration
@AutoConfigureAfter(DubboRelaxedBindingAutoConfiguration.class)
@EnableConfigurationProperties(DubboConfigurationProperties.class)
@Import(ServiceBeanIdConflictProcessor.class)
public class DubboAutoConfiguration {
    /**
     * Creates {@link ReferenceAnnotationBeanPostProcessor} Bean if Absent
     *
     * @return {@link ReferenceAnnotationBeanPostProcessor}
     */
    @ConditionalOnMissingBean
    @Bean(name = ReferenceAnnotationBeanPostProcessor.BEAN_NAME)
    public ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor() {
        return new ReferenceAnnotationBeanPostProcessor();
    }
```

- 因为 `ReferenceAnnotationBeanPostProcessor` 继承了`AbstractAnnotationBeanPostProcessor`, 最终会执行 `ReferenceAnnotationBeanPostProcessor` 中的重写方法 `doGetInjectedBean` ，也就是实现bean的依赖注入的方法。

在这个方法中，主要做两个事情
    - 注册一个ReferenceBean到SpringIOC容器中
    - 调用`getOrCreateProxy`返回一个动态代理对象

```java
// 处理标有 @DubboReference、@Reference、@com.alibaba.dubbo.config.annotation.Reference 的注解的依赖注入
public ReferenceAnnotationBeanPostProcessor() {    
    super(DubboReference.class, Reference.class, com.alibaba.dubbo.config.annotation.Reference.class);
}


//获得被注入对象
// bean: SayController
// attributes: @DubboReference上配置的参数
// injectedType：SayController的接口
@Override
protected Object doGetInjectedBean(AnnotationAttributes attributes, Object bean, String beanName, Class<?> injectedType, InjectionMetadata.InjectedElement injectedElement) throws Exception {
    // referencedBeanName = ServiceBean:com.sendbp.dubbo.ISayHelloService
    String referencedBeanName = buildReferencedBeanName(attributes, injectedType);
    // referenceBeanName = @Reference(check=false,cluster=failfast,loadbalance=consistenthash,mock=com.sendbp.dubbo.springbootdubboconsumer.MockSayHelloService,protocol=dubbo,registry=[Ljava.lang.String;@5befbac1,retries=5,timeout=500) com.sendbp.dubbo.ISayHelloService
    String referenceBeanName = getReferenceBeanName(attributes, injectedType);
    // 构建一个ReferenceBean
    ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referenceBeanName, attributes, injectedType);
    // 是否通过本地服务调用
    boolean localServiceBean = isLocalServiceBean(referencedBeanName, referenceBean, attributes);
    // 将 ReferenceBean 注入到IOC容器
    registerReferenceBean(referencedBeanName, referenceBean, attributes, localServiceBean, injectedType);
    // 缓存 ReferenceBean
    cacheInjectedReferenceBean(referenceBean, injectedElement);
    // 获取或者创建代理对象
    return getOrCreateProxy(referencedBeanName, referenceBean, localServiceBean, injectedType);
}
```

### ReferenceBean

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201113144737.jpg)

从类图上可以看到，ReferenceBean实现了FactoryBean，说明它是个工厂bena类，依赖注入时，会注入一个代理类。

### 1. buildReferenceBeanIfAbsent

```java
private ReferenceBean buildReferenceBeanIfAbsent(String referenceBeanName, AnnotationAttributes attributes, Class<?> referencedType) throws Exception {
    
    ReferenceBean<?> referenceBean = referenceBeanCache.get(referenceBeanName);
    
    if (referenceBean == null) {
        ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder.create(attributes, applicationContext).interfaceClass(referencedType);
        referenceBean = beanBuilder.build(); // 构建referenceBean 
        referenceBeanCache.put(referenceBeanName, referenceBean); // 存入缓存
    } else if (!referencedType.isAssignableFrom(referenceBean.getInterfaceClass())) {
        throw new IllegalArgumentException("reference bean name " + referenceBeanName + " has been duplicated, but interfaceClass " +
                referenceBean.getInterfaceClass().getName() + " cannot be assigned to " + referencedType.getName());
    }
    return referenceBean;
}
```

### 2. registerReferenceBean

```java
private void registerReferenceBean(String referencedBeanName, ReferenceBean referenceBean, AnnotationAttributes attributes, boolean localServiceBean, Class<?> interfaceClass) {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    String beanName = getReferenceBeanName(attributes, interfaceClass);
    if (localServiceBean) {  // 加载本地服务
        /**
        * Get  the @Service's BeanDefinition from {@link BeanFactory}
        * Refer to {@link ServiceAnnotationBeanPostProcessor#buildServiceBeanDefinition}
        */
        AbstractBeanDefinition beanDefinition = (AbstractBeanDefinition) beanFactory.getBeanDefinition(referencedBeanName);
        RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) beanDefinition.getPropertyValues().get("ref");
        // The name of bean annotated @Service
        String serviceBeanName = runtimeBeanReference.getBeanName();
        // register Alias rather than a new bean name, in order to reduce duplicated beans
        beanFactory.registerAlias(serviceBeanName, beanName);
    } else { // 加载远程服务
        if (!beanFactory.containsBean(beanName)) {
            beanFactory.registerSingleton(beanName, referenceBean);
        }
    }
}
```

### 3. getOrCreateProxy

```java
private Object getOrCreateProxy(String referencedBeanName, ReferenceBean referenceBean, boolean localServiceBean, Class<?> serviceInterfaceType) {
    if (localServiceBean) { // 判断是否加载本地服务
        return newProxyInstance(getClassLoader(), new Class[]{serviceInterfaceType},
                newReferencedBeanInvocationHandler(referencedBeanName));
    } else { // 加载远程服务
        exportServiceBeanIfNecessary(referencedBeanName); // If the referenced ServiceBean exits, export it immediately
        return referenceBean.get(); // 返回一个动态代理类
    }
}
```

可以看到，最终返回的动态代理对象，是通过referenceBean.get();来获得的。

### 4. ReferenceConfig.get

> ReferenceBean继承了ReferenceConfig。ReferenceBean#get方法 调用 ReferenceConfig#get 方法

```java
public synchronized T get() {
    if (destroyed) {
        throw new IllegalStateException("The invoker of ReferenceConfig(" + url + ") has already destroyed!");
    }
    if (ref == null) {
        init();
    }
    return ref;
}
```

### 5. init 方法

开始调用init方法进行ref也就是代理对象的初始化动作

- 检查配置信息
- 根据dubbo配置，构建map集合
- 调用 createProxy 创建动态代理对象

```java
public synchronized void init() {
    // 如果已经初始化，则直接返回
    if (initialized) {
        return;
    }
    if (bootstrap == null) {
        bootstrap = DubboBootstrap.getInstance();
        bootstrap.init();
    }
    // 检查配置
    checkAndUpdateSubConfigs();
    // 检查本地存根  local与stub
    checkStubAndLocal(interfaceClass);
    ConfigValidationUtils.checkMock(interfaceClass, this);
    Map<String, String> map = new HashMap<String, String>();
    map.put(SIDE_KEY, CONSUMER_SIDE);
    // 添加运行时参数
    ReferenceConfigBase.appendRuntimeParameters(map);
    // 检查是否为泛化接口
    if (!ProtocolUtils.isGeneric(generic)) {
        // 获取版本信息
        String revision = Version.getVersion(interfaceClass, version);
        if (revision != null && revision.length() > 0) {
            map.put(REVISION_KEY, revision);
        }
        // 获取接口方法列表，添加到map中
        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        if (methods.length == 0) {
            logger.warn("No method found in service interface " + interfaceClass.getName());
            map.put(METHODS_KEY, ANY_VALUE);
        } else {
            map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), COMMA_SEPARATOR));
        }
    }
    // 通过class加载配置信息
    map.put(INTERFACE_KEY, interfaceName);
    AbstractConfig.appendParameters(map, getMetrics());
    AbstractConfig.appendParameters(map, getApplication());
    AbstractConfig.appendParameters(map, getModule());
    // remove 'default.' prefix for configs from ConsumerConfig
    // appendParameters(map, consumer, Constants.DEFAULT_KEY);
    AbstractConfig.appendParameters(map, consumer);
    AbstractConfig.appendParameters(map, this);
    // 将元数据配置信息放入map中
    MetadataReportConfig metadataReportConfig = getMetadataReportConfig();
    if (metadataReportConfig != null && metadataReportConfig.isValid()) {
        map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);
    }
    // 遍历methodConfig，组装method参数信息
    Map<String, AsyncMethodInfo> attributes = null;
    if (CollectionUtils.isNotEmpty(getMethods())) {
        attributes = new HashMap<>();
        for (MethodConfig methodConfig : getMethods()) {
            AbstractConfig.appendParameters(map, methodConfig, methodConfig.getName());
            // 如果没有设置重试，默认为0
            String retryKey = methodConfig.getName() + ".retry";
            if (map.containsKey(retryKey)) {
                String retryValue = map.remove(retryKey);
                if ("false".equals(retryValue)) {
                    map.put(methodConfig.getName() + ".retries", "0");
                }
            }
            AsyncMethodInfo asyncMethodInfo = AbstractConfig.convertMethodConfig2AsyncInfo(methodConfig);
            if (asyncMethodInfo != null) {
//                    consumerModel.getMethodModel(methodConfig.getName()).addAttribute(ASYNC_KEY, asyncMethodInfo);
                attributes.put(methodConfig.getName(), asyncMethodInfo);
            }
        }
    }
    // 获取服务消费者ip地址
    String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);
    if (StringUtils.isEmpty(hostToRegistry)) {
        hostToRegistry = NetUtils.getLocalHost();
    } else if (isInvalidLocalHost(hostToRegistry)) {
        throw new IllegalArgumentException("Specified invalid registry ip from property:" + DUBBO_IP_TO_REGISTRY + ", value:" + hostToRegistry);
    }
    map.put(REGISTER_IP_KEY, hostToRegistry);
    serviceMetadata.getAttachments().putAll(map);
    ref = createProxy(map); // 创建代理类
    serviceMetadata.setTarget(ref);
    serviceMetadata.addAttribute(PROXY_CLASS_REF, ref);
    ConsumerModel consumerModel = repository.lookupReferredService(serviceMetadata.getServiceKey());
    consumerModel.setProxyObject(ref);
    consumerModel.init(attributes);
    initialized = true;
    // dispatch a ReferenceConfigInitializedEvent since 2.7.4
    dispatch(new ReferenceConfigInitializedEvent(this, invoker));
}
```

### 5. ReferenceConfig.createProxy

> 首先我们需要注意一个点，这里是创建一个代理对象，而这个代理对象应该也和协议有关系，也就是不同的协议，使用的代理对象也应该不一样。

那我们还是先来分析下面的代码。 

- 首先检查是不是本地调用，如果是，则使用injvm protocol的refer方法产生一个InjvmInvoker实例 
- 否则，再判断是否是点对点通信，也就是url参数不为空，而url参数又可以配置多个，所以这里需要遍历 
- 遍历所有注册中心的url，针对每个注册中心协议构建invoker，并保存到invokers中 
- 通过Cluster的StaticDirectory把多个静态注册中心组件成一个集群

```java
private T createProxy(Map<String, String> map) {
    if (shouldJvmRefer(map)) { // 是不是本地 injvm协议调用
        URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);
        invoker = REF_PROTOCOL.refer(interfaceClass, url);
        if (logger.isInfoEnabled()) {
            logger.info("Using injvm service " + interfaceClass.getName());
        }
    } else { // 远程服务
        urls.clear();
        // url 是通过 @DubboReference(url = "") 得来的，可以配置多个，通过 ，分割
        if (url != null && url.length() > 0) {
            String[] us = SEMICOLON_SPLIT_PATTERN.split(url); // 分割
            if (us != null && us.length > 0) {
                for (String u : us) {
                    URL url = URL.valueOf(u);
                    if (StringUtils.isEmpty(url.getPath())) {
                        url = url.setPath(interfaceName);
                    }
                    if (UrlUtils.isRegistry(url)) {
                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));
                    } else {
                        urls.add(ClusterUtils.mergeUrl(url, map));
                    }
                }
            }
        } else { // assemble URL from register center's configuration
            // if protocols not injvm checkRegistry
            // 远程调用，检查协议是否injvm协议（injvm://）
            if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) {
                checkRegistry(); // 检查注册中心配置
                // 得到注册中心上的注册地址（如果配置多个注册中心，这里就会有多个注册地址 registry://）
                List<URL> us = ConfigValidationUtils.loadRegistries(this, false);
                if (CollectionUtils.isNotEmpty(us)) {
                    for (URL u : us) {
                        // 获取监视器地址，<dubbo:monitor address="10.211.55.5:9090" />
                        URL monitorUrl = ConfigValidationUtils.loadMonitor(this, u);
                        if (monitorUrl != null) {
                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
                        }
                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));
                    }
                }
                if (urls.isEmpty()) {
                    throw new IllegalStateException("No such any registry to reference " + interfaceName + " on the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", please config <dubbo:registry address=\"...\" /> to your spring config.");
                }
            }
        }
        if (urls.size() == 1) { // 只配置一个注册中心
            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));
        } else { // 配置多个注册中心， 都分别构建一个invoker
            List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
            URL registryURL = null;
            for (URL url : urls) { // 遍历注册中心地址，进行处理
                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));
                if (UrlUtils.isRegistry(url)) {
                    registryURL = url; // use last registry url
                }
            }
            
            //如果registryURL不为空 
            //则通过CLUSTER.join把invokers以静态的Directory形式构建一个invoker对象。 
            //目的是实现注册中心的路由
            if (registryURL != null) { // registry url is available
                // for multi-subscription scenario, use 'zone-aware' policy by default
                URL u = registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);
                // The invoker wrap relation would be like: ZoneAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, routing happens here) -> Invoker
                // 注册地址试不变的，registry，创建StaticDirectory包装
                invoker = CLUSTER.join(new StaticDirectory(u, invokers));
            } else { // not a registry url, must be direct invoke.
                invoker = CLUSTER.join(new StaticDirectory(invokers));
            }
        }
    }
    if (shouldCheck() && !invoker.isAvailable()) {
        invoker.destroy();
        throw new IllegalStateException("Failed to check the status of the service "
                + interfaceName
                + ". No provider available for the service "
                + (group == null ? "" : group + "/")
                + interfaceName +
                (version == null ? "" : ":" + version)
                + " from the url "
                + invoker.getUrl()
                + " to the consumer "
                + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion());
    }
    if (logger.isInfoEnabled()) {
        logger.info("Refer dubbo service " + interfaceClass.getName() + " from url " + invoker.getUrl());
    }
    /**
        * @since 2.7.0
        * ServiceData Store
        */
    String metadata = map.get(METADATA_KEY);
    WritableMetadataService metadataService = WritableMetadataService.getExtension(metadata == null ? DEFAULT_METADATA_STORAGE_TYPE : metadata);
    if (metadataService != null) {
        URL consumerURL = new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map);
        metadataService.publishServiceDefinition(consumerURL);
    }
    // create service proxy
    return (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));
}
```

在上面这个方法中，有两个核心的代码需要关注，分别是。 

- REF_PROTOCOL.refer， 这个是生成invoker对象，之前我们说过，它是一个调用器，是dubbo中 比较重要的领域对象，它在这里承担这服务调用的核心逻辑. 
- PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic)), 构建一个代理对象，代理客户端的请求。


### 6. REF_PROTOCOL.refer

REF_PROTOCOL是一个自适应扩展点，现在我们看到这个代码，应该是比较熟悉了。它会生成一个 Protocol$Adaptive的类，然后根据refer传递的的url参数来决定当前路由到哪个具体的协议处理器。

```java
Protocol REF_PROTOCOL = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
```

前面已经分析服务发布的时候，已经说过了这个过程，所以就跳过，直接进入到RegistryProtocol.refer 中

#### (1) RegistryProtocol.refer

RegistryProtocol这个类我们已经很熟悉了，服务注册和服务启动都是在这个类里面触发的。 现在我们又通过这个方法来获得一个inovker对象，那我们继续去分析refer里面做了什么事情。 这里面的代码逻辑比较简单 

- 组装注册中心协议的url 
- 判断是否配置了group，如果有，则`cluster=getMergeableCluster()`，构建invoker 
- doRefer构建invoker

```java
@Override
@SuppressWarnings("unchecked")
public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
    // 获得注册中心的url地址
    // 此时，这里得到的是 zookeeper://
    url = getRegistryUrl(url);
    // registryFactory，是一个自适应扩展点，RegistryFactory$Adaptive
    // 定位到org.apache.dubbo.registry.RegistryFactory这个类可以知道，返回的实例是: ZookeeperRegistryFactory,并且是一个被RegistryFactoryWrapper包装的实例。RegistryFactoryWrapper(ZookeeperRegistryFactory())
    Registry registry = registryFactory.getRegistry(url);
    if (RegistryService.class.equals(type)) {
        return proxyFactory.getInvoker((T) registry, type, url);
    }
    // group="a,b" or group="*" 
    // 是否进行分组调用
    Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
    String group = qs.get(GROUP_KEY);
    if (group != null && group.length() > 0) {
        if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || "*".equals(group)) {
            return doRefer(getMergeableCluster(), registry, type, url);
        }
    }
    return doRefer(cluster, registry, type, url);
}
```

#### (2) doRefer

doRefer方法创建一个RegistryDirectory实例，然后生成服务者消费者连接，并向注册中心进行注册。 注册完毕后，紧接着订阅providers、configurators、roters 等节点下的数据。完成订阅后，RegistryDirectory会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在providers产生多个节点， 这个时候就需要Cluster将多个服务节点合并为一个，并生成一个invoker。

```java
private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
    // 动态服务地址发现
    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
    directory.setRegistry(registry); // 注册对象 zookeeperRegistry 
    directory.setProtocol(protocol); // 协议信息
    
    
    // all attributes of REFER_KEY
    Map<String, String> parameters = new HashMap<String, String>(directory.getConsumerUrl().getParameters());
    URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);
    if (directory.isShouldRegister()) { // 是否需要注册
        // 注册 consumer:// 协议url
        directory.setRegisteredConsumerUrl(subscribeUrl); // 设置订阅地址
        registry.register(directory.getRegisteredConsumerUrl());
    }
    directory.buildRouterChain(subscribeUrl);
    // 进行订阅 
    // subscribe: 订阅信息: 消费url、通知监听、配置监听、订阅url 
    // toSubscribeUrl: 订阅信息：category、providers、configurators、routers
    directory.subscribe(toSubscribeUrl(subscribeUrl)); // 订阅。订阅地址变化
    
    
    //一个注册中心会存在多个服务提供者，所以在这里需要把多个服务提供者通过cluster.join合并成 一个
    Invoker<T> invoker = cluster.join(directory); // 通过这里获取invoker
    List<RegistryProtocolListener> listeners = findRegistryProtocolListeners(url);
    if (CollectionUtils.isEmpty(listeners)) {
        return invoker;
    }
    RegistryInvokerWrapper<T> registryInvokerWrapper = new RegistryInvokerWrapper<>(directory, cluster, invoker, subscribeUrl);
    for (RegistryProtocolListener listener : listeners) {
        listener.onRefer(this, registryInvokerWrapper);
    }
    return registryInvokerWrapper;
}
```

看完上面的代码，是不是有一种一脸懵逼的感觉，doRefer到底做了什么？ 

只是初始化了一个RegistryDirectory，然后通过 Cluster.join 来返回一个Invoker对象？如果我们只需要关注核心流程，那么首先我们来看一下Cluster是什么？


### 7. CLUSTER是什么


我们只关注一下Invoker这个代理类的创建过程,其他的暂且不关心

```java
Invoker invoker = cluster.join(directory)
```

cluster其实是在RegistryProtocol中通过set方法完成依赖注入的，并且，它还是一个被包装的。

```java
public void setCluster(Cluster cluster) {
    this.cluster = cluster;
}
```

Cluster是一个被依赖注入的自适应扩展点，注入的对象实例是一个Cluster$Adaptive的动态代理类。

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201113160045.jpg)

```java
@SPI(FailoverCluster.NAME) // failover
public interface Cluster {
    @Adaptive
    <T> Invoker<T> join(Directory<T> directory) throws RpcException;
}
```

#### (1) Cluster$Adaptive

在动态适配的类中会基于extName，选择一个合适的扩展点进行适配，由于默认情况下 cluster:failover，所以 getExtension("failover")理论上应该返回FailOverCluster。但实际上，这里做了包装 MockClusterWrapper（FailOverCluster）

```java
public class Cluster$Adaptive implements org.apache.dubbo.rpc.cluster.Cluster {
    
    public org.apache.dubbo.rpc.Invoker join(org.apache.dubbo.rpc.cluster.Directory arg0) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.cluster.Directory argument == null");
        if (arg0.getUrl() == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null");
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = url.getParameter("cluster", "failover"); // 获取配置cluster属性（降级策略），如果没有配置默认采用 failover
        if(extName == null) 
            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.cluster.Cluster) name from url (" + url.toString() + ") use keys([cluster])");
        org.apache.dubbo.rpc.cluster.Cluster extension = (org.apache.dubbo.rpc.cluster.Cluster)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);
        return extension.join(arg0);
    }
    
}
```

Cluster接口里还有一个MockClusterWrapper包装类，最终返回的是 MockClusterWrapper(Cluster() )

#### (2) cluster.join

所以再回到doRefer方法，下面这段代码, 实际是调用MockClusterWrapper(FailOverCluster.join)

```java
public class MockClusterWrapper implements Cluster {
    private Cluster cluster;
    public MockClusterWrapper(Cluster cluster) {
        this.cluster = cluster;
    }
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new MockClusterInvoker<T>(directory, this.cluster.join(directory));
    }
}
```

再调用AbstractCluster中的join方法

```java
@Override
public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
    return buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));
}
```

doJoin返回的是 FailoverClusterInvoker 还是 ZoneAwareClusterInvoker，取决于当前是什么Cluster对象，当如果有两个注册中心，会采用ZoneAwareCluster类来处理。

> 具体业务逻辑在org.apache.dubbo.config.ReferenceConfig#createProxy方法中可以看到
>
> ![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201117162658.jpg)

**ZoneAwareCluster (多注册中心)**

```java
public class ZoneAwareCluster extends AbstractCluster {
    public final static String NAME = "zone-aware";
    @Override
    protected <T> AbstractClusterInvoker<T> doJoin(Directory<T> directory) throws RpcException {
        return new ZoneAwareClusterInvoker<T>(directory);
    }
}
```

**failoverCluster (单注册中心)**

```java
public class FailoverCluster extends AbstractCluster {
    public final static String NAME = "failover";
    @Override
    public <T> AbstractClusterInvoker<T> doJoin(Directory<T> directory) throws RpcException {
        return new FailoverClusterInvoker<>(directory);
    }
}
```

> buildClusterInterceptors 

从名字可以看出，这里是构建一个Cluster的拦截器。

```java
// failoverCluster 的父类 AbstractCluster
public abstract class AbstractCluster implements Cluster {
    // 构建一个拦截器 链路
    private <T> Invoker<T> buildClusterInterceptors(AbstractClusterInvoker<T> clusterInvoker, String key) {
        AbstractClusterInvoker<T> last = clusterInvoker;
        // 通过激活扩展点来获得 ClusterInterceptor 集合. 如果没有配置激活参数，默认会有一个 ConsumerContextClusterInterceptor拦截器.
        List<ClusterInterceptor> interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor.class).getActivateExtension(clusterInvoker.getUrl(), key);
        // 遍历拦截器集合，构建一个拦截器链.
        if (!interceptors.isEmpty()) {
            for (int i = interceptors.size() - 1; i >= 0; i--) {
                final ClusterInterceptor interceptor = interceptors.get(i);
                final AbstractClusterInvoker<T> next = last;
                last = new InterceptorInvokerNode<>(clusterInvoker, interceptor, next);
            }
        }
        // 最终返回的last= InterceptorInvokerNode
        return last;
    }
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        // doJoin(directory) ==> new FailoverClusterInvoker<>(directory);
        return buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));
    }
    
    protected abstract <T> AbstractClusterInvoker<T> doJoin(Directory<T> directory) throws RpcException;
```

```java
// 默认会获取 ConsumerContextClusterInterceptor 实例
List<ClusterInterceptor> interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor.class).getActivateExtension(clusterInvoker.getUrl(), key);
```

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201114144225.jpg)



#### (3) Cluster.join 总结

因此 Cluster.join，实际上是获得一个Invoker对象，这个Invoker实现了Directory的包装，并且配置了 拦截器。至于它是干嘛的，我们后续再分析。

### 8. PROXY_FACTORY.getProxy (ReferenceConfig.createProxy)

返回了Invoker之后，再回到createProxy这段代码中，这里最终会调用一个getProxy来返回一个动态代理对象。 并且这里把invoker作为参数传递进去，上面我们知道invoker这个对象的构建过程，实际上封装了一个 directory在invoker中。

```java
return (T) PROXY_FACTORY.getProxy(invoker, ProtocolUtils.isGeneric(generic));
```

而这里的proxyFactory是一个自适应扩展点，它会根据url中携带的proxy参数来决定选择哪种动态代理 技术来构建动态代理对象，默认是javassist

```java
import org.apache.dubbo.common.extension.ExtensionLoader;

public class ProxyFactory$Adaptive implements org.apache.dubbo.rpc.ProxyFactory {
    
    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument == null");
        if (arg0.getUrl() == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument getUrl() == null");
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = url.getParameter("proxy", "javassist"); // 获取url上的proxy属性值，如果没有默认用javassist
        if(extName == null) 
            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (" + url.toString() + ") use keys([proxy])");
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getProxy(arg0);
    }

    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0, boolean arg1) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument == null");
        if (arg0.getUrl() == null) 
            throw new IllegalArgumentException("org.apache.dubbo.rpc.Invoker argument getUrl() == null");
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = url.getParameter("proxy", "javassist");
        if(extName == null) 
            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (" + url.toString() + ") use keys([proxy])");
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getProxy(arg0, arg1);
    }

    public org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {
        if (arg2 == null) 
            throw new IllegalArgumentException("url == null");
        org.apache.dubbo.common.URL url = arg2;
        String extName = url.getParameter("proxy", "javassist");
        if(extName == null) 
            throw new IllegalStateException("Failed to get extension (org.apache.dubbo.rpc.ProxyFactory) name from url (" + url.toString() + ") use keys([proxy])");
        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);
        return extension.getInvoker(arg0, arg1, arg2);
    }
}
    
```

#### (1) JavassistProxyFactory.getProxy

通过这个方法生成了一个动态代理类，并且对invoker再做了一层处理，InvokerInvocationHandler。 意味着后续发起服务调用的时候，会由InvokerInvocationHandler来进行处理。

```java
public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
	return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
}
```

注意：

```java
// 1. return sayHelloService.sayHello("Mic");
// 2. return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
// 调用 sayHelloService.sayHello 方法，实际上是调用InvokerInvocationHandler#invoke()
```

#### (2) org.apache.dubbo.common.bytecode.Proxy#getProxy

在proxy.getProxy这个方法中会生成一个动态代理类，通过debug的形式可以看到动态代理类的原貌在getProxy这个方法位置加一个断点

然后在debug窗口，找到ccp这个变量 -> mMethods。

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201117100917.jpg)

```java
public java.lang.String sayHello(java.lang.String arg0){
    Object[] args = new Object[1]; 
    args[0] = ($w)$1; 
    Object ret = handler.invoke(this, methods[1], args); 
    return (java.lang.String)ret;
}
```

从这个sayHello方法可以看出，我们通过 @Reference注入的一个对象实例本质上就是一个动态代理类，通过调用这个类中的方法，会触发 handler.invoke(), 而这个handler就是InvokerInvocationHandler

#### (3) 小结

至此，我们在分析服务消费者的动态代理的构建过程中可以发现，虽然代码非常非常的多，但是本质上就做了两件事情。 

1. 构建一个RegistryDirectory对象 
2. 生成远程服务的代理 

那么这里我们又要思考了，服务地址的获取呢？ 远程通信的建立呢？如果这些步骤没有完成，难倒再用 户调用指定方法的时候再操作吗？ 很明显是不现实的对吧。 

因此我们又得往前面翻代码，去看看动态代理的构建过程中，是不是还有什么地方存在遗漏的呢？

### 9. RegistryDirectory

大家还记得在RegistryProtocol中，调用doRefer这个方法吗？

这个doRefer方法中，构建了一个RegistryDirectory，之前我们不明白Directory的含义，所以暂时没有管，但是它的作用很重要，它负责动态维护服务提供者列表。

```java
private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {
    // 动态服务地址发现
    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
    directory.setRegistry(registry); // 注册对象 zookeeperRegistry 
    directory.setProtocol(protocol); // 协议信息
    
    
    // all attributes of REFER_KEY
    Map<String, String> parameters = new HashMap<String, String>(directory.getConsumerUrl().getParameters());
    URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);
    if (directory.isShouldRegister()) { // 是否需要注册
        // 注册 consumer:// 协议url
        directory.setRegisteredConsumerUrl(subscribeUrl); // 设置订阅地址
        registry.register(directory.getRegisteredConsumerUrl());
    }
    directory.buildRouterChain(subscribeUrl);
    // 进行订阅 
    // subscribe: 订阅信息: 消费url、通知监听、配置监听、订阅url 
    // toSubscribeUrl: 订阅信息：category、providers、configurators、routers
    directory.subscribe(toSubscribeUrl(subscribeUrl)); // 订阅。订阅地址变化
    
    
    //一个注册中心会存在多个服务提供者，所以在这里需要把多个服务提供者通过cluster.join合并成 一个
    Invoker<T> invoker = cluster.join(directory); // 通过这里获取invoker
    List<RegistryProtocolListener> listeners = findRegistryProtocolListeners(url);
    if (CollectionUtils.isEmpty(listeners)) {
        return invoker;
    }
    RegistryInvokerWrapper<T> registryInvokerWrapper = new RegistryInvokerWrapper<>(directory, cluster, invoker, subscribeUrl);
    for (RegistryProtocolListener listener : listeners) {
        listener.onRefer(this, registryInvokerWrapper);
    }
    return registryInvokerWrapper;
}
```

#### (1) 服务目录

RegistryDirectory是Dubbo中的服务目录，从名字上来看，也比较容易理解，服务目录中存储了一些和 服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务 协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。 

以下是它的类关系图. 

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201113154537.jpg)

从这个图上不难发现，Dubbo提供了两种服务目录，一种是静态的（StaticDirectory），另一种是基于注册中心的（RegistryDirectory）。基于注册中心，那我们是不是清楚，注册中心会有一个动态更新服务列表的机制，因此RegistryDirectory实现了NotifyListener这个接口，也就是当服务地址发生变化时，RegistryDirectory中维护的地址列表需要及时变更。 

```java
public interface NotifyListener {
    /**
     * Triggered when a service change notification is received.
     * <p>
     * Notify needs to support the contract: <br>
     * 1. Always notifications on the service interface and the dimension of the data type. that is, won't notify part of the same type data belonging to one service. Users do not need to compare the results of the previous notification.<br>
     * 2. The first notification at a subscription must be a full notification of all types of data of a service.<br>
     * 3. At the time of change, different types of data are allowed to be notified separately, e.g.: providers, consumers, routers, overrides. It allows only one of these types to be notified, but the data of this type must be full, not incremental.<br>
     * 4. If a data type is empty, need to notify a empty protocol with category parameter identification of url data.<br>
     * 5. The order of notifications to be guaranteed by the notifications(That is, the implementation of the registry). Such as: single thread push, queue serialization, and version comparison.<br>
     *
     * @param urls The list of registered information , is always not empty. The meaning is the same as the return value of {@link org.apache.dubbo.registry.RegistryService#lookup(URL)}.
     */
    void notify(List<URL> urls);
}
```

所以，再回忆一下之前我们通过Cluster.join去构建Invoker时，传递了一个directory进去，是不是也能 够理解为什么这么做了呢？因为Invoker是一个调用器，在发起远程调用时，必然需要从directory中去 拿到所有的服务提供者列表，然后再通过负载均衡机制来发起请求。

#### (2) RegistryDirectory.subscribe

订阅注册中心指定节点的变化，如果发生变化，则通知到RegistryDirectory。Directory其实和服务的注册以及服务的发现有非常大的关联.

```java
public void subscribe(URL url) {
    setConsumerUrl(url);
    // 把当前RegistryDirectory作为listener，去监听zk上节点的变化
    CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);
    serviceConfigurationListener = new ReferenceConfigurationListener(this, url);
    registry.subscribe(url, this); // zookeeperRegistry对象 执行订阅 操作 -> 这里的registry是zookeeperRegsitry
}
```

此时，registry我们知道，它是ListenerRegistryWrapper(ZookeeperRegsistry)对象，我们先不管包装类，直接进入到ZookeeperRegistry这个类中

#### (3) FailbackRegistry.subscribe

> ZookeeperRegsistry的父类是FailbackRegistry，而ZookeeperRegsistry中没有subscribe方法；registry.subscribe这个方法，最终会调用 FailbackRegistry.subscrbe

其中入参， listener为RegistryDirectory，后续要用到 failbackRegistry 这个类，从名字就可以看出，它的主要作用就是实现具有故障恢复功能的服务订阅机制，简单来说就是如果在订阅服务注册中心时出现异常，会触发重试机制。

```java
@Override
public void subscribe(URL url, NotifyListener listener) {
    super.subscribe(url, listener);
    //移除失效的listener，调用doSubscribe进行订阅
    removeFailedSubscribed(url, listener);
    try {
        // Sending a subscription request to the server side
        // 发送订阅请求到服务端
        doSubscribe(url, listener);
    } catch (Exception e) {
        Throwable t = e;

        List<URL> urls = getCacheUrls(url);
        if (CollectionUtils.isNotEmpty(urls)) {
            notify(url, listener, urls);
            logger.error("Failed to subscribe " + url + ", Using cached list: " + urls + " from cache file: " + getUrl().getParameter(FILE_KEY, System.getProperty("user.home") + "/dubbo-registry-" + url.getHost() + ".cache") + ", cause: " + t.getMessage(), t);
        } else {
            // If the startup detection is opened, the Exception is thrown directly.
            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                && url.getParameter(Constants.CHECK_KEY, true);
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) {
                if (skipFailback) {
                    t = t.getCause();
                }
                throw new IllegalStateException("Failed to subscribe " + url + ", cause: " + t.getMessage(), t);
            } else {
                logger.error("Failed to subscribe " + url + ", waiting for retry, cause: " + t.getMessage(), t);
            }
        }

        // Record a failed registration request to a failed list, retry regularly
        // 记录失败的注册订阅请求，根据规则进行重试
        addFailedSubscribed(url, listener);
    }
}

public abstract void doSubscribe(URL url, NotifyListener listener);
```

#### (4) zookeeperRegistry.doSubscribe(url, this); 

这个方法是订阅，逻辑实现比较多，可以分两段来看，这里的实现把所有Service层发起的订阅以及指定的Service层发起的订阅分开处理。所有Service层类似于监控中心发起的订阅。指定的Service层发起的 订阅可以看作是服务消费者的订阅。我们只需要关心指定service层发起的订阅即可

```java
@Override
public void doSubscribe(final URL url, final NotifyListener listener) {
    try {
        //针对所有service层发起的订阅
        if (ANY_VALUE.equals(url.getServiceInterface())) {
            String root = toRootPath();
            ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
            ChildListener zkListener = listeners.computeIfAbsent(listener, k -> (parentPath, currentChilds) -> {
                for (String child : currentChilds) {
                    child = URL.decode(child);
                    if (!anyServices.contains(child)) {
                        anyServices.add(child);
                        subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,
                                Constants.CHECK_KEY, String.valueOf(false)), k);
                    }
                }
            });
            zkClient.create(root, false);
            List<String> services = zkClient.addChildListener(root, zkListener);
            if (CollectionUtils.isNotEmpty(services)) {
                for (String service : services) {
                    service = URL.decode(service);
                    anyServices.add(service);
                    subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,
                            Constants.CHECK_KEY, String.valueOf(false)), listener);
                }
            }
        } else {
            // 针对指定的服务地址发起订阅
            // toCategoriesPath 会返回三个结果，分别是/providers、/configurations、/routers。 也就是服务启动时需要监听这三个节点下的数据变化
            List<URL> urls = new ArrayList<>();
            for (String path : toCategoriesPath(url)) {
                // 构建一个listeners集合，其中key是NotifyListener，其中前面我们知道	RegistryDirectory实现了这个接口，所以这里的key应该是RegistryDirectory
			   // value表示针对这个RegistryDirectory注册的子节点监听

                ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.computeIfAbsent(url, k -> new ConcurrentHashMap<>());
                ChildListener zkListener = listeners.computeIfAbsent(listener, k -> (parentPath, currentChilds) -> ZookeeperRegistry.this.notify(url, k, toUrlsWithEmpty(url, parentPath, currentChilds)));
                //创建一个/providers or /configurators、/routers节点
                zkClient.create(path, false);
                List<String> children = zkClient.addChildListener(path, zkListener);
                if (children != null) {
                    urls.addAll(toUrlsWithEmpty(url, path, children));
                }
            }
            //调用notify方法触发监听
            notify(url, listener, urls);
        }
    } catch (Throwable e) {
        throw new RpcException("Failed to subscribe " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

#### (5) FailbackRegistry.notify

> zookeeperRegistry#doSubscribe 调用 notify方法，是调用父类 FailbackRegistry.notify

调用 FailbackRegistry.notify， 对参数进行判断。 然后调用AbstractRegistry.notify方法

```java
@Override
protected void notify(URL url, NotifyListener listener, List<URL> urls) {
    if (url == null) {
        throw new IllegalArgumentException("notify url == null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("notify listener == null");
    }
    try {
        doNotify(url, listener, urls);
    } catch (Exception t) {
        // Record a failed registration request to a failed list, retry regularly
        addFailedNotified(url, listener, urls);
        logger.error("Failed to notify for subscribe " + url + ", waiting for retry, cause: " + t.getMessage(), t);
    }
}

protected void doNotify(URL url, NotifyListener listener, List<URL> urls) {
    super.notify(url, listener, urls);
}
```

#### (6) AbstractRegistry.notify

这里面会针对每一个category，调用listener.notify进行通知，然后更新本地的缓存文件

```java
protected void notify(URL url, NotifyListener listener, List<URL> urls) {
    if (url == null) {
        throw new IllegalArgumentException("notify url == null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("notify listener == null");
    }
    if ((CollectionUtils.isEmpty(urls))
        && !ANY_VALUE.equals(url.getServiceInterface())) {
        logger.warn("Ignore empty notify urls for subscribe url " + url);
        return;
    }
    if (logger.isInfoEnabled()) {
        logger.info("Notify urls for subscribe url " + url + ", urls: " + urls);
    }
    // keep every provider's category.
    Map<String, List<URL>> result = new HashMap<>();
    for (URL u : urls) {//urls表示三个empty://协议的地址
        if (UrlUtils.isMatch(url, u)) {
            String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
            List<URL> categoryList = result.computeIfAbsent(category, k -> new ArrayList<>());
            categoryList.add(u);
        }
    }
    if (result.size() == 0) {
        return;
    }
    Map<String, List<URL>> categoryNotified = notified.computeIfAbsent(url, u -> new ConcurrentHashMap<>());
    for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
        String category = entry.getKey();
        List<URL> categoryList = entry.getValue();
        categoryNotified.put(category, categoryList);
        listener.notify(categoryList); // 通过listener监听categoryList
        // 保存到本地文件中，作为服务地址的缓存信息
        // We will update our cache file after each notification.
        // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.
        saveProperties(url);
    }
}
```

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201116145412.jpg)

上述代码中，我们重点关注 `listener.notify` ，它会触发一个事件通知，消费端的listener是最开始传递过来的RegistryDirectory，所以这里会触发 `RegistryDirectory.notify`

#### (7) RegistryDirectory.notify

看到这个代码，大家是不是更进一步理解了，服务地址发生变化和更新时，调用`Directory.notify`来更新，那么是不是意味着更新后的信息，会同步到Directory中呢？ 带着这个思考，我们继续去分析代码。

```java
@Override
public synchronized void notify(List<URL> urls) {
    //对数据进行过滤。
    Map<String, List<URL>> categoryUrls = urls.stream()
        .filter(Objects::nonNull)
        .filter(this::isValidCategory)
        .filter(this::isNotCompatibleFor26x)
        .collect(Collectors.groupingBy(this::judgeCategory));
	// 假设当前进来的通知是 providers节点
    // 判断configurator是否为空，这个节点下的配置，是在dubbo-admin控制台上修改配置时，会先创建一个配置节点到这个路径下，注册中心收到这个变化时会通知服务消费者，服务消费者会根据新的配置重新构建Invoker
    List<URL> configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());
    this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators);
	// 判断路由规则配置是否为空，如果不为空，同样将路由规则添加到url中。
    List<URL> routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());
    toRouters(routerURLs).ifPresent(this::addRouters);

    // providers 得到服务提供者的地址列表
    List<URL> providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());
    /**
     * 3.x added for extend URL address
     */
    // 获得一个地址监听的激活扩展点。 这里目前应该还没有任何实现，可以先不用管
    ExtensionLoader<AddressListener> addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);
    List<AddressListener> supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);
    if (supportedListeners != null && !supportedListeners.isEmpty()) {
        for (AddressListener addressListener : supportedListeners) {
            providerURLs = addressListener.notify(providerURLs, getConsumerUrl(),this);
        }
    }
    // 刷新覆盖调用程序
    refreshOverrideAndInvoker(providerURLs);
}
```

#### (8) refreshOverrideAndInvoker

- 逐个调用注册中心里面的配置，覆盖原来的url，组成最新的url 放入 overrideDirectoryUrl 存储， 此时我们没有在dubbo-admin中修改任何配置，所以这里没必要去分析 
- 根据 provider urls，重新刷新Invoker

```java
private void refreshOverrideAndInvoker(List<URL> urls) {
    // mock zookeeper://xxx?mock=return null
    // 付给DirectoryUrl
    overrideDirectoryUrl();
    // 刷新invoker
    refreshInvoker(urls);
}
```

#### (9) refreshInvoker

从名字可以看到，这里是刷新invoker。怎么理解呢？ 

当注册中心的服务地址发生变化时，会触发更新。而更新之后并不是直接把url地址存储到内存，而是把url转化为invoker进行存储，这个invoker是作为通信的调用器来构建的领域对象，所以如果地址发生变化，那么需要把老的invoker销毁，然后用心的invoker替代。

```java
private void refreshInvoker(List<URL> invokerUrls) {
    Assert.notNull(invokerUrls, "invokerUrls should not be null");
	// 如果只有一个服务提供者，并且如果是空协议，那么这个时候直接返回进制访问，并且销毁所有的invokers
    if (invokerUrls.size() == 1
        && invokerUrls.get(0) != null
        && EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
        
        this.forbidden = true; // Forbid to access
        this.invokers = Collections.emptyList();
        routerChain.setInvokers(this.invokers);
        destroyAllInvokers(); // Close all invokers
    } else { // 第一次初始化的时候，invokerUrls为空
        this.forbidden = false; // Allow to access
        // 获取老的invoker集合
        Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
        if (invokerUrls == Collections.<URL>emptyList()) { // 为null则初始化
            invokerUrls = new ArrayList<>();
        }
        if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
            invokerUrls.addAll(this.cachedInvokerUrls);
        } else {
            this.cachedInvokerUrls = new HashSet<>();
            this.cachedInvokerUrls.addAll(invokerUrls); // Cached invoker urls, convenient for comparison
        }
        if (invokerUrls.isEmpty()) {
            return;
        }
        Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls); // Translate url list to Invoker map

        /**
        * If the calculation is wrong, it is not processed.
        *
        * 1. The protocol configured by the client is inconsistent with the protocol of the server.
        *    eg: consumer protocol = dubbo, provider only has other protocol services(rest).
        * 2. The registration center is not robust and pushes illegal specification data.
        *
        */
        if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {
            logger.error(new IllegalStateException("urls to invokers error .invokerUrls.size :" + invokerUrls.size() + ", invoker.size :0. urls :" + invokerUrls.toString()));
            return;
        }
	    // 转化为list
        List<Invoker<T>> newInvokers = Collections.unmodifiableList(new ArrayList<>(newUrlInvokerMap.values()));
        // pre-route and build cache, notice that route cache should build on original Invoker list.
        // toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.
        routerChain.setInvokers(newInvokers);
        // 如果服务配置了分组，则把分组下的provider包装成StaticDirectory,组成一个invoker
		// 实际上就是按照group进行合并		
        this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
        this.urlInvokerMap = newUrlInvokerMap;

        try {
            // 旧的url 是否在新map里面存在，不存在，就是销毁url对应的Invoker
            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
        } catch (Exception e) {
            logger.warn("destroyUnusedInvokers error. ", e);
        }
    }
}

```

#### (10) toInvokers

这个方法中有比较长的判断和处理逻辑，我们只需要关心invoker是什么时候初始化的就行。 这里用到了protocol.refer来构建了一个invoker 

`invoker = new InvokerDelegate<>(protocol.refer(serviceType, url), url, providerUrl);` 

构建完成之后，会保存在 Map> urlInvokerMap 这个集合中

```java
private Map<String, Invoker<T>> toInvokers(List<URL> urls) {
    Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<>();
    if (urls == null || urls.isEmpty()) {
        return newUrlInvokerMap;
    }
    Set<String> keys = new HashSet<>();
    String queryProtocols = this.queryMap.get(PROTOCOL_KEY);
    for (URL providerUrl : urls) {
        // If protocol is configured at the reference side, only the matching protocol is selected
        if (queryProtocols != null && queryProtocols.length() > 0) {
            boolean accept = false;
            String[] acceptProtocols = queryProtocols.split(",");
            for (String acceptProtocol : acceptProtocols) {
                if (providerUrl.getProtocol().equals(acceptProtocol)) {
                    accept = true;
                    break;
                }
            }
            if (!accept) {
                continue;
            }
        }
        if (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
            continue;
        }
        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
            logger.error(new IllegalStateException("Unsupported protocol " + providerUrl.getProtocol() + " in notified url: " + providerUrl + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost() + ", supported protocol: " + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
            continue;
        }
        URL url = mergeUrl(providerUrl);

        String key = url.toFullString(); // The parameter urls are sorted
        if (keys.contains(key)) { // Repeated url
            continue;
        }
        keys.add(key);
        // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference
        Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
        if (invoker == null) { // Not in the cache, refer again
            try {
                boolean enabled = true;
                if (url.hasParameter(DISABLED_KEY)) {
                    enabled = !url.getParameter(DISABLED_KEY, false);
                } else {
                    enabled = url.getParameter(ENABLED_KEY, true);
                }
                if (enabled) {
                    invoker = new InvokerDelegate<>(protocol.refer(serviceType, url), url, providerUrl);
                }
            } catch (Throwable t) {
                logger.error("Failed to refer invoker for interface:" + serviceType + ",url:(" + url + ")" + t.getMessage(), t);
            }
            if (invoker != null) { // Put new invoker in cache
                newUrlInvokerMap.put(key, invoker);
            }
        } else {
            newUrlInvokerMap.put(key, invoker);
        }
    }
    keys.clear();
    return newUrlInvokerMap;
}
```

#### (11) 总结

简单总结一下，RegistryDirectory.subscribe，其实总的来说就相当于做了两件事

- 定于指定注册中心的以下三个路径的子节点变更事件

  ```sh
  /dubbo/org.apache.dubbo.demo.DemoService/providers、
  /dubbo/org.apache.dubbo.demo.DemoService/configurators、
  /dubbo/org.apache.dubbo.demo.DemoService/routers
  ```

- 触发时间变更之后，把变更的节点信息转化为Invoker

再回顾一下Cluster.join这个操作，把RegistryDirectory作为参数传递进去了，那么是不是意味着返回的 invoker中可以拿到真正的服务提供者地址，然后进行远程访问呢？所以你看，源码的阅读也没有那么难。

### 10. protocol.refer

咱们继续往下看，在toInvokers这个方法中，invoker是通过 `protocol.refer` 来构建的。那么我们再来分析一下refer里面做了什么？

```java
invoker = new InvokerDelegate<>(protocol.refer(serviceType, url), url, providerUrl);
```

不过在往下分析之前，我们先来猜想一下它会做什么？根据在这段逻辑所处的位置和它在整个dubbo中 的作用，我们应该可以猜测出。

- 这个invoker应该和通信有关系
- 那么这里应该会建立一个网络通信的连接

根据猜想，我们去看一下它的实现，首先protocol，是被依赖注入进来的自适应扩展点 Protocol$Adaptive. ，此时传进去的参数，此时url对应的地址应该是dubbo://开头的协议地址，所以最终获得的是通过包装之后的DubboProtocol对象。

> QosProtocolWrapper(ProtocolFilterWrapper(ProtocolListenerWrapper(DubboProtocol)))

其中，在Qos这边，会启动QosServer、在FilterWrapper中，会构建一个过滤器链，其中包含访问日志过滤、访问限制过滤等等，这个最终在调用的时候会通过一条过滤器链路对请求进行处理。

#### (1) AbstractProtocol.refer

DubboProtocol中没有refer方法，而是调用父类的refer。

```java
@Override
public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
	return new AsyncToSyncInvoker<>(protocolBindingRefer(type, url));
}
```

#### (2) protocolBindingRefer

- 优化序列化 
- 构建DubboInvoker

在构建DubboInvoker时，会构建一个ExchangeClient，通过getClients(url)方法，这里基本可以猜到到是服务的通信建立

```java
@Override
public <T> Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url) throws RpcException {
    optimizeSerialization(url);

    // create rpc invoker.
    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
    invokers.add(invoker);

    return invoker;
}
```

#### (3) getClients

这里面是获得客户端连接的方法 

- 判断是否为共享连接，默认是共享同一个连接进行通信 
- 是否配置了多个连接通道 connections，默认只有一个共享连接

```java
private ExchangeClient[] getClients(URL url) {
    // whether to share connection

    boolean useShareConnect = false;

    int connections = url.getParameter(CONNECTIONS_KEY, 0);
    List<ReferenceCountExchangeClient> shareClients = null;
    // if not configured, connection is shared, otherwise, one connection for one service
    // 如果没有配置的情况下，默认是采用共享连接，否则，就是针对一个服务提供一个连接。
	//所谓共享连接，实际上就是长连接通信
    if (connections == 0) {
        useShareConnect = true;

        /*
             * The xml configuration should have a higher priority than properties.
             */
        String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) null);
        connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY, DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);
        //返回共享连接
        shareClients = getSharedClient(url, connections);
    }
	//从共享连接中获得客户端连接进行返回
    ExchangeClient[] clients = new ExchangeClient[connections];
    for (int i = 0; i < clients.length; i++) {
        if (useShareConnect) {
            clients[i] = shareClients.get(i);

        } else {{//如果不是使用共享连接，则初始化一个新的客户端连接进行返回
            clients[i] = initClient(url);
        }
    }

    return clients;
}
```

#### (4) getSharedClient（返回共享连接）

```java
private List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum) {
    String key = url.getAddress();
    List<ReferenceCountExchangeClient> clients = referenceClientMap.get(key);
    // 检查当前的key检查连接是否已经创建过并且可用，如果是，则直接返回并且增加连接的个数的统计

    if (checkClientCanUse(clients)) {
        batchClientRefIncr(clients);
        return clients;
    }
	// 如果连接已经关闭或者连接没有创建过
    locks.putIfAbsent(key, new Object());
    synchronized (locks.get(key)) {
        clients = referenceClientMap.get(key);
        // dubbo check
        // 双重检查
        if (checkClientCanUse(clients)) {
            batchClientRefIncr(clients);
            return clients;
        }

        // connectNum must be greater than or equal to 1
        // 连接数必须大于等于1
        connectNum = Math.max(connectNum, 1);

        // If the clients is empty, then the first initialization is
        // 如果当前消费者还没有和服务端产生连接，则初始化
        if (CollectionUtils.isEmpty(clients)) {
            clients = buildReferenceCountExchangeClientList(url, connectNum);
            referenceClientMap.put(key, clients);

        } else {//如果clients不为空，则从clients数组中进行遍历
            for (int i = 0; i < clients.size(); i++) {
                ReferenceCountExchangeClient referenceCountExchangeClient = clients.get(i);
                // If there is a client in the list that is no longer available, create a new one to replace him.
                // 如果在集合中存在一个连接但是这个连接处于closed状态，则重新构建一个进行替换
                if (referenceCountExchangeClient == null || referenceCountExchangeClient.isClosed()) {
                    clients.set(i, buildReferenceCountExchangeClient(url));
                    continue;
                }
				//增加个数		
                referenceCountExchangeClient.incrementAndGetCount();
            }
        }

        /*
             * I understand that the purpose of the remove operation here is to avoid the expired url key
             * always occupying this memory space.
             */
        locks.remove(key);

        return clients;
    }
}
```

#### (5) buildReferenceCountExchangeClient

开始初始化客户端连接. 也就是说，dubbo消费者在启动的时候，先从注册中心上加载最新的服务提供者地址，然后转化成 invoker，但是转化的时候，也会同步去建立一个连接。 

而这个连接默认采用的是共享连接，因此就会存在对于同一个服务提供者，假设客户端依赖了多个 @DubboReference，那么这个时候这些服务的引用会使用同一个连接进行通信。

```java
private ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url) {
    ExchangeClient exchangeClient = initClient(url);

    return new ReferenceCountExchangeClient(exchangeClient);
}
```

#### (6) initClient 

终于进入到初始化客户端连接的方法了，猜测应该是根据url中配置的参数进行远程通信的构建

```java
private ExchangeClient initClient(URL url) {

    // client type setting.
    // 获取客户端通信类型，默认是netty
    String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));
	// 获取编码解码类型，默认是Dubbo自定义类型	
    url = url.addParameter(CODEC_KEY, DubboCodec.NAME);
    // enable heartbeat by default
    // 开启心跳并设置心跳间隔，默认60s
    url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));

    // BIO is not allowed since it has severe performance issue.
    // 如果没有找到指定类型的通信扩展点，则抛出异常。
    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported client type: " + str + "," +
                               " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));
    }

    ExchangeClient client;
    try {
        // connection should be lazy
        // 是否延迟建立连接
        if (url.getParameter(LAZY_CONNECT_KEY, false)) {
            client = new LazyConnectExchangeClient(url, requestHandler);

        } else {// 默认是直接在启动时建立连接
            client = Exchangers.connect(url, requestHandler);
        }

    } catch (RemotingException e) {
        throw new RpcException("Fail to create remoting client for service(" + url + "): " + e.getMessage(), e);
    }

    return client;
}
```

#### (7) Exchangers.connect

创建一个客户端连接

```java
public static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
    if (url == null) {
        throw new IllegalArgumentException("url == null");
    }
    if (handler == null) {
        throw new IllegalArgumentException("handler == null");
    }
    url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");
    return getExchanger(url).connect(url, handler);
}
```

HeaderExchange.connect

```java
@Override
public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);
}
```

#### (8) NettyTransport.connect

使用netty构建了一个客户端连接

```java
@Override
public Client connect(URL url, ChannelHandler handler) throws RemotingException {
    return new NettyClient(url, handler);
}
```

#### (9) 总结

我们讲到了 `RegistryProtocol.refer` 过程中有一个关键步骤，即在监听到服务提供者url时触发 `RegistryDirectory.notify()` 方法。 

`RegistryDirectory.notify()` 方法调用 `refreshInvoker()` 方法将服务提供者urls转换为对应的远程invoker ，最终调用到 `DubboProtocol.refer()` 方法生成对应的 DubboInvoker 。

 DubboInvoker 的构造方法中有一项入参 `ExchangeClient[] clients` ，即对应本文要讲的网络客户 端 Client 。DubboInvoker就是通过调用 `client.request()` 方法完成网络通信的请求发送和响应接收功能。 

Client 的具体生成过程就是通过 `DubboProtocol 的 initClient(URL url)` 方法创建了一个 `HeaderExchangeClient` 。



### 服务调用过程

服务启动过程中，主要会构建一个动态代理类，并且在构建动态代理之前，会从注册中心上获取服务提供者的地址，并且会订阅服务提供者的状态。 

然后，采用DubboProtocol协议，和服务端建立一个远程通信，并保存到Invoker中进行返回。 

那接下来，我们再去看服务调用的时候，请求的执行过程。

#### (1) JavassistProxyFactory.getProxy

在创建代理对象时，会执行下面这段代码，一旦代码被调用，就会触发InvokerInvocationHandler。

```java
public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
	return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
}
```

当调用sayHello方法时，会触发handler.invoker

```java
public java.lang.String sayHello(java.lang.String arg0){
    Object[] args = new Object[1];
    args[0] = ($w)$1;
    Object ret = handler.invoke(this, methods[0], args);
    return (java.lang.String) ret;
}
```

#### (2) InvokerInvocationHandler.invoke

进入到InvokerInvocationHandler.invoke方法。 

其中invoker这个对象， 是在启动注入动态代理类时，初始化的一个调用器对象，我们得先要知道它是 谁，才能知道它下一步调用的是哪个对象的方法. 

它应该是： MockClusterInvoker，因为它是通过 MockClusterWrapper 来进行包装的。

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (method.getDeclaringClass() == Object.class) {
        return method.invoke(invoker, args);
    }
    String methodName = method.getName();
    //获得参数类型
    Class<?>[] parameterTypes = method.getParameterTypes();
    if (parameterTypes.length == 0) {
        if ("toString".equals(methodName)) {
            return invoker.toString();
        } else if ("$destroy".equals(methodName)) {
            invoker.destroy();
            return null;
        } else if ("hashCode".equals(methodName)) {
            return invoker.hashCode();
        }
    } else if (parameterTypes.length == 1 && "equals".equals(methodName)) {
        return invoker.equals(args[0]);
    }
    //数据传输对象
    RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), args);
    String serviceKey = invoker.getUrl().getServiceKey();
    rpcInvocation.setTargetServiceUniqueName(serviceKey);

    if (consumerModel != null) {
        rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);
        rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));
    }

    return invoker.invoke(rpcInvocation).recreate();
}
```

#### (3) MockClusterInvoker

Mock，在这里面有两个逻辑 

1. 是否客户端强制配置了mock调用，那么在这种场景中主要可以用来解决服务端还没开发好的时候 直接使用本地数据进行测试 
2. 是否出现了异常，如果出现异常则使用配置好的Mock类来实现服务的降级

```java
@Override
public Result invoke(Invocation invocation) throws RpcException {
    Result result = null;
	// 获取 mock 属性值（降级配置）
    String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();
    if (value.length() == 0 || "false".equalsIgnoreCase(value)) {
        // 直接调用
        result = this.invoker.invoke(invocation);
    } else if (value.startsWith("force")) { // 强制执行 降级
        if (logger.isWarnEnabled()) {
            logger.warn("force-mock: " + invocation.getMethodName() + " force-mock enabled , url : " + getUrl());
        }
        //force:direct mock
        result = doMockInvoke(invocation, null);
    } else {
        //fail-mock
        try {
            result = this.invoker.invoke(invocation); // 执行下一步操作

            // 如果出现异常，执行降级
            if(result.getException() != null && result.getException() instanceof RpcException){
                RpcException rpcException= (RpcException)result.getException();
                if (rpcException.isBiz()) {
                    throw rpcException;
                } else {
                    result = doMockInvoke(invocation, rpcException);
                }
            }

        } catch (RpcException e) {
            if (e.isBiz()) {
                throw e;
            }

            if (logger.isWarnEnabled()) {
                logger.warn("fail-mock: " + invocation.getMethodName() + " fail-mock enabled , url : " + getUrl(), e);
            }
            // 如果出现异常，执行降级
            result = doMockInvoke(invocation, e);
        }
    }
    return result;
}
// 反射调用降级方法
private Result doMockInvoke(Invocation invocation, RpcException e) {
    Result result = null;
    Invoker<T> minvoker;

    List<Invoker<T>> mockInvokers = selectMockInvoker(invocation);
    if (CollectionUtils.isEmpty(mockInvokers)) {
        minvoker = (Invoker<T>) new MockInvoker(getUrl(), directory.getInterface());
    } else {
        minvoker = mockInvokers.get(0);
    }
    try {
        result = minvoker.invoke(invocation);
    } catch (RpcException me) {
        if (me.isBiz()) {
            result = AsyncRpcResult.newDefaultAsyncResult(me.getCause(), invocation);
        } else {
            throw new RpcException(me.getCode(), getMockExceptionMessage(e, me), me.getCause());
        }
    } catch (Throwable me) {
        throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
    }
    return result;
}
```

#### (4) AbstractCluster$InterceptorInvokerNode.invoker

为什么到这个类，看过前面生成动态代理过程的同学应该都知道，invoker会通过一个Interceptor进行包装。构建了一个拦截器链。 

> 具体逻辑在org.apache.dubbo.rpc.cluster.support.wrapper.AbstractCluster#buildClusterInterceptors中。
>
> ```java
> public abstract class AbstractCluster implements Cluster {
> 
>     private <T> Invoker<T> buildClusterInterceptors(AbstractClusterInvoker<T> clusterInvoker, String key) {
>         AbstractClusterInvoker<T> last = clusterInvoker;
>         List<ClusterInterceptor> interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor.class).getActivateExtension(clusterInvoker.getUrl(), key);
> 
>         if (!interceptors.isEmpty()) {
>             for (int i = interceptors.size() - 1; i >= 0; i--) {
>                 final ClusterInterceptor interceptor = interceptors.get(i);
>                 final AbstractClusterInvoker<T> next = last;
>                 // 这里创建一个InterceptorInvokerNode类。在MockClusterInvoker调用invoke时，就会进入InterceptorInvokerNode#invoke
>                 last = new InterceptorInvokerNode<>(clusterInvoker, interceptor, next); 
>             }
>         }
>         return last;
>     }
> 
>     @Override
>     public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
>         return buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));
>     }
> 
>     protected abstract <T> AbstractClusterInvoker<T> doJoin(Directory<T> directory) throws RpcException;
> 
>     protected class InterceptorInvokerNode<T> extends AbstractClusterInvoker<T> {
> 
>         private AbstractClusterInvoker<T> clusterInvoker;
>         private ClusterInterceptor interceptor;
>         private AbstractClusterInvoker<T> next;
> 
>         public InterceptorInvokerNode(AbstractClusterInvoker<T> clusterInvoker,
>                                       ClusterInterceptor interceptor,
>                                       AbstractClusterInvoker<T> next) {
>             this.clusterInvoker = clusterInvoker;
>             this.interceptor = interceptor;
>             this.next = next;
>         }
> 
>         @Override
>         public Class<T> getInterface() {
>             return clusterInvoker.getInterface();
>         }
> 
>         @Override
>         public URL getUrl() {
>             return clusterInvoker.getUrl();
>         }
> 
>         @Override
>         public boolean isAvailable() {
>             return clusterInvoker.isAvailable();
>         }
> 
>         @Override
>         public Result invoke(Invocation invocation) throws RpcException {
>             Result asyncResult;
>             try {
>                 interceptor.before(next, invocation); // 调用拦截器前置操作
>                 asyncResult = interceptor.intercept(next, invocation); // 调用拦截操作
>             } catch (Exception e) {
>                 // onError callback
>                 if (interceptor instanceof ClusterInterceptor.Listener) {
>                     ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;
>                     listener.onError(e, clusterInvoker, invocation);
>                 }
>                 throw e;
>             } finally {
>                 interceptor.after(next, invocation);
>             }
>             return asyncResult.whenCompleteWithContext((r, t) -> {
>                 // onResponse callback
>                 if (interceptor instanceof ClusterInterceptor.Listener) {
>                     ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;
>                     if (t == null) {
>                         listener.onMessage(r, clusterInvoker, invocation);
>                     } else {
>                         listener.onError(t, clusterInvoker, invocation);
>                     }
>                 }
>             });
>         }
> 
>         @Override
>         public void destroy() {
>             clusterInvoker.destroy();
>         }
> 
>         @Override
>         public String toString() {
>             return clusterInvoker.toString();
>         }
> 
>         @Override
>         protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
>             // The only purpose is to build a interceptor chain, so the cluster related logic doesn't matter.
>             return null;
>         }
>     }
> }
> ```
>
> 

这个拦截器是的组成是： ConsumerContextClusterInterceptor -next-> ZoneAwareClusterInvoker 

其中before方法是设置上下文信息，接着调用interceptor.interceppt方法进行拦截处理

#### (5) ClusterInterceptor.intercept

> 因为ConsumerContextClusterInterceptor拦截器中没有intercept方法，直接往接口调用ClusterInterceptor.intercept

```java
default Result intercept(AbstractClusterInvoker<?> clusterInvoker, Invocation invocation) throws RpcException {
	return clusterInvoker.invoke(invocation); // 这里的clusterInvoker是 通过doJoin(directory)获得 自适应扩展点，默认的扩展点是 failoverCluster
}
```

此时传递过来的clusterInvoker对象，是拦截器链中的第二个节点 ZoneAwareClusterInvoker(多个注册中心采用)，failoverCluster(单注册中心采用)

#### (6) AbstractClusterInvoker.invoke

```java
@Override
public Result invoke(final Invocation invocation) throws RpcException {
    checkWhetherDestroyed();

    // binding attachments into invocation.
    // 绑定attachment到invocation中
    Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();
    if (contextAttachments != null && contextAttachments.size() != 0) {
        ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);
    }
	// 获取invoker列表，这里的列表应该是直接从directory中获取	
    List<Invoker<T>> invokers = list(invocation);
    // 初始化负载均衡算法
    LoadBalance loadbalance = initLoadBalance(invokers, invocation);
    // 调用子类的doInvoke方法
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
    return doInvoke(invocation, invokers, loadbalance);
}
```

#### (7) ZoneAwareClusterInvoker.doInvoke

ZonAwareCluster，就是之前我们说过的，如果一个服务注册在多个注册中心，那么消费者去消费时， 会根据区域进行路由，选择一个注册中心进行服务消费。

```java
@Override
@SuppressWarnings({"unchecked", "rawtypes"})
public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    // First, pick the invoker (XXXClusterInvoker) that comes from the local registry, distinguish by a 'preferred' key.
    //遍历注册中心
    for (Invoker<T> invoker : invokers) {
        // 判断是否需要通过mockInvoker来触发调用
        // FIXME, the invoker is a cluster invoker representing one Registry, so it will automatically wrapped by MockClusterInvoker.
        MockClusterInvoker<T> mockClusterInvoker = (MockClusterInvoker<T>) invoker;
        if (mockClusterInvoker.isAvailable() && mockClusterInvoker.getRegistryUrl()
            .getParameter(REGISTRY_KEY + "." + PREFERRED_KEY, false)) {
            return mockClusterInvoker.invoke(invocation);
        }
    }

    // providers in the registry with the same zone
    // 是否制定了zone进行调用
    String zone = (String) invocation.getAttachment(REGISTRY_ZONE);
    if (StringUtils.isNotEmpty(zone)) {
        for (Invoker<T> invoker : invokers) {
            MockClusterInvoker<T> mockClusterInvoker = (MockClusterInvoker<T>) invoker;
            if (mockClusterInvoker.isAvailable() && zone.equals(mockClusterInvoker.getRegistryUrl().getParameter(REGISTRY_KEY + "." + ZONE_KEY))) {
                return mockClusterInvoker.invoke(invocation);
            }
        }
        String force = (String) invocation.getAttachment(REGISTRY_ZONE_FORCE);
        if (StringUtils.isNotEmpty(force) && "true".equalsIgnoreCase(force)) {
            throw new IllegalStateException("No registry instance in zone or no available providers in the registry, zone: "
                                            + zone
                                            + ", registries: " + invokers.stream().map(invoker -> ((MockClusterInvoker<T>) invoker).getRegistryUrl().toString()).collect(Collectors.joining(",")));
        }
    }


    // load balance among all registries, with registry weight count in.
    // 通过负载均衡算法，从多个注册中心中随机选择一个节点
    Invoker<T> balancedInvoker = select(loadbalance, invocation, invokers, null);
    if (balancedInvoker.isAvailable()) {// 进入到指定注册中心的服务列表进行调用
        return balancedInvoker.invoke(invocation);
    }
	
    // 如果没有一个invoker通过负载均衡算法被指定,则选择第一个有效的invoker进行调用。
    // If none of the invokers has a preferred signal or is picked by the loadbalancer, pick the first one available.
    for (Invoker<T> invoker : invokers) {
        MockClusterInvoker<T> mockClusterInvoker = (MockClusterInvoker<T>) invoker;
        if (mockClusterInvoker.isAvailable()) {
            // 选择指定的一个区域的invoker进行调用
            return mockClusterInvoker.invoke(invocation);
        }
    }
    throw new RpcException("No provider available in " + invokers);
}
```

调用链路又会经过一遍 MockClusterInvoker - > AbstractCluster$InterceptorInvokerNode

#### (8) AbstractCluster$InterceptorInvokerNode.invoker

再次进入到这个方法中，不过此时的调用链路发生了变化。 

这个拦截器是的组成是： `ConsumerContextClusterInterceptor -next-> FailoverClusterInvoker` 继续进入到AbstractClusterInvoker中的invoke，但是此时AbstractClusterInvoker是通过 FailoverClusterInvoker来实现的，所以再次调用doInvoke时，会调用FailoverClusterInvoker中的 doInvoke方法

```java
public Result invoke(final Invocation invocation) throws RpcException {
    checkWhetherDestroyed();
    // binding attachments into invocation.
    Map<String, Object> contextAttachments =
    RpcContext.getContext().getObjectAttachments();
    if (contextAttachments != null && contextAttachments.size() != 0) {
    	((RpcInvocation) invocation).addObjectAttachments(contextAttachments);
    }
    List<Invoker<T>> invokers = list(invocation);
    LoadBalance loadbalance = initLoadBalance(invokers, invocation);
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
    return doInvoke(invocation, invokers, loadbalance);
}
```

#### (9) FailoverClusterInvoker.doInvoke

FailoverClusterInvoker，顾名思义，就是集群容错的处理，默认的集群容错策略是重试，所以也不难 猜出这里面的实现方式。 

这段代码逻辑也很好理解，因为我们之前在讲Dubbo的时候说过容错机制，而failover是失败重试，所 以这里面应该会实现容错的逻辑 

- 获得重试的次数，并且进行循环 
- 获得目标服务，并且记录当前已经调用过的目标服务防止下次继续将请求发送过去 
- 如果执行成功，则返回结果 
- 如果出现异常，判断是否为业务异常，如果是则抛出，否则，进行下一次重试



![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/dubbo/20201117213446.jpg)

- 这里的 Invoker 是 Provider 的一个可调用 Service 的抽象， Invoker 封装了 Provider 地 址及 Service 接口信息 
- Directory 代表多个 Invoker ，可以把它看成 List ，但与 List 不同的是，它的 值可能是动态变化的，比如注册中心推送变更 
- Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker ，对上层透明，伪装过程包含 了容错逻辑，调用失败后，重试另一个 
- Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 
- LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡 算法，调用失败后，需要重选

```java
@Override
@SuppressWarnings({"unchecked", "rawtypes"})
public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    // 获取服务提供者的协议invoker
    List<Invoker<T>> copyInvokers = invokers;
    // 校验invoker
    checkInvokers(copyInvokers, invocation);
    // 获取调用的目标方法名
    String methodName = RpcUtils.getMethodName(invocation);
    // 获得重试次数
    int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1;
    if (len <= 0) {
        len = 1;
    }
    // retry loop.
    RpcException le = null; // last exception.
    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
    Set<String> providers = new HashSet<String>(len);
    // 循环重试
    for (int i = 0; i < len; i++) {
        //Reselect before retry to avoid a change of candidate `invokers`.
        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.
        if (i > 0) {
            checkWhetherDestroyed();
            copyInvokers = list(invocation);
            // check again
            checkInvokers(copyInvokers, invocation);
        }
        // 从多个invoker中通过负载均衡算法，选择一个inovke进行调用
        Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
        invoked.add(invoker);// 记录已经调用过的目标服务，如果重试时，已经调用过的目标服务不再发起调用
        RpcContext.getContext().setInvokers((List) invoked);
        try {
            // 发起远程调用
            Result result = invoker.invoke(invocation);
            if (le != null && logger.isWarnEnabled()) {
                logger.warn("Although retry the method " + methodName
                            + " in the service " + getInterface().getName()
                            + " was successful by the provider " + invoker.getUrl().getAddress()
                            + ", but there have been failed providers " + providers
                            + " (" + providers.size() + "/" + copyInvokers.size()
                            + ") from the registry " + directory.getUrl().getAddress()
                            + " on the consumer " + NetUtils.getLocalHost()
                            + " using the dubbo version " + Version.getVersion() + ". Last error is: "
                            + le.getMessage(), le);
            }
            return result;
        } catch (RpcException e) {
            if (e.isBiz()) { // biz exception.
                throw e;
            }
            le = e;
        } catch (Throwable e) {
            le = new RpcException(e.getMessage(), e);
        } finally {
            providers.add(invoker.getUrl().getAddress());
        }
    }
    throw new RpcException(le.getCode(), "Failed to invoke the method "
                           + methodName + " in the service " + getInterface().getName()
                           + ". Tried " + len + " times of the providers " + providers
                           + " (" + providers.size() + "/" + copyInvokers.size()
                           + ") from the registry " + directory.getUrl().getAddress()
                           + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
                           + Version.getVersion() + ". Last error is: "
                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);
}
```

#### (10) 负载均衡算法

- loadbalance 表示具体的负载均衡算法实例 
- invocation 表示请求的参数
- invokers，表示服务提供者的实例列表，如果有多个，这里就是一个集合 

> org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker#select

```java
protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {

    if (CollectionUtils.isEmpty(invokers)) {
        return null;
    }
    String methodName = invocation == null ? StringUtils.EMPTY_STRING : invocation.getMethodName();

    boolean sticky = invokers.get(0).getUrl()
        .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);

    //ignore overloaded method
    if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
        stickyInvoker = null;
    }
    //ignore concurrency problem
    if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
        if (availablecheck && stickyInvoker.isAvailable()) {
            return stickyInvoker;
        }
    }

    Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);

    if (sticky) {
        stickyInvoker = invoker;
    }
    return invoker;
}
```

> org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker#doSelect

```java
private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation, List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {

    if (CollectionUtils.isEmpty(invokers)) {
        return null;
    }
    if (invokers.size() == 1) { //如果invokers只有一个，则直接返回
        return invokers.get(0);
    }
    // 否则，调用负载均衡算法获得一个目标invoker
    Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);

    //If the `invoker` is in the  `selected` or invoker is unavailable && availablecheck is true, reselect.
    // 如果selected集合中包含这次选择出来的invoker， 或这invoker是一个失效的服务，则重新选择一个新的invoker返回。
    if ((selected != null && selected.contains(invoker))
        || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
        try {
            Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
            if (rInvoker != null) {
                invoker = rInvoker;
            } else {
                //Check the index of current selected invoker, if it's not the last one, choose the one at index+1.
                int index = invokers.indexOf(invoker);
                try {
                    //Avoid collision
                    invoker = invokers.get((index + 1) % invokers.size());
                } catch (Exception e) {
                    logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
                }
            }
        } catch (Throwable t) {
            logger.error("cluster reselect fail reason is :" + t.getMessage() + " if can not solve, you can set cluster.availablecheck=false in url", t);
        }
    }
    return invoker;
}
```

**RandomLoadBalance.doSelect**

```java
@Override
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    // Number of invokers
    int length = invokers.size();
    // Every invoker has the same weight?
    boolean sameWeight = true;
    // the weight of every invokers
    // 下面这个循环有两个作用，第一是计算总权重 totalWeight，
	// 第二是检测每个服务提供者的权重是否相同
    int[] weights = new int[length];
    // the first invoker's weight
    int firstWeight = getWeight(invokers.get(0), invocation);
    weights[0] = firstWeight;
    // The sum of weights
    int totalWeight = firstWeight;
    for (int i = 1; i < length; i++) {
        int weight = getWeight(invokers.get(i), invocation);
        // save for later use
        weights[i] = weight;
        // 累加权重
        totalWeight += weight;
        // 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，
		// 不相同的话，则将 sameWeight 置为 false。
        if (sameWeight && weight != firstWeight) {
            sameWeight = false;
        }
    }
    // 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上
    if (totalWeight > 0 && !sameWeight) {
        // 随机获取一个 [0, totalWeight) 区间内的数字
        // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.
        int offset = ThreadLocalRandom.current().nextInt(totalWeight);
        // Return a invoker based on the random value.
        // 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。
        // 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。
        // 第一次循环，offset - 5 = 2 > 0，即 offset > 5，
        // 表明其不会落在服务器 A 对应的区间上。
        // 第二次循环，offset - 3 = -1 < 0，即 5 < offset < 8，
        // 表明其会落在服务器 B 对应的区间上
        for (int i = 0; i < length; i++) {
            // 让随机值 offset 减去权重值
            offset -= weights[i];
            if (offset < 0) {
                // 返回相应的 Invoker
                return invokers.get(i);
            }
        }
    }
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    // 如果所有服务提供者权重值相同，此时直接随机返回一个即可
    return invokers.get(ThreadLocalRandom.current().nextInt(length));
}
```

#### (11) invoker.invoke

这里会通过负载返回的invoker对象，来调用 invoke方法进行远程通信。

```java
Result result = invoker.invoke(invocation);
```

invoker对象的组成是： RegistryDirectory$InvokerDelegate() -> ProtocolFilterWrapper -> ListenerInvokerWrapper 

其中，在ProtocolFilterWrapper的调用中，实际会调用一个匿名内部类的invoke方法，这里构建了一 个filter进行逐项的过滤，

**AsyncToSyncInvoker.invoke**

经过装饰器、过滤器对invoker进行增强和过滤之后，来到了AsyncToSyncInvoker.invoke方法，这里采 用的是异步的方式来进行通信

```java
@Override
public Result invoke(Invocation invocation) throws RpcException {
    // 这里执行调用，但是是异步调用。
    Result asyncResult = invoker.invoke(invocation);

    try {
        //如果配置的是同步通信，则通过get阻塞式获取返回结果
        if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) {
            /**
                 * NOTICE!
                 * must call {@link java.util.concurrent.CompletableFuture#get(long, TimeUnit)} because
                 * {@link java.util.concurrent.CompletableFuture#get()} was proved to have serious performance drop.
                 */
            asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
        }
    } catch (InterruptedException e) {
        throw new RpcException("Interrupted unexpectedly while waiting for remote result to return!  method: " +
                               invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
    } catch (ExecutionException e) {
        Throwable t = e.getCause();
        if (t instanceof TimeoutException) {
            throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " +
                                   invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        } else if (t instanceof RemotingException) {
            throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " +
                                   invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        } else {
            throw new RpcException(RpcException.UNKNOWN_EXCEPTION, "Fail to invoke remote method: " +
                                   invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        }
    } catch (Throwable e) {
        throw new RpcException(e.getMessage(), e);
    }
    return asyncResult;
}
```

**DubboInvoker.invoke**

DubboInvoker继承了AbstractInvoker这个抽象类，而DubboInvoker中没有invoke这个方法，所以这 里调用的是AbstractInvoker.invoke方法。 

进入到DubboInvoker这个方法中，那么意味着正式进入到服务通信层面了。前面的很多细节分析，无 非就是做了三件事 

- 多注册中心的拦截以及分发 
- 负载均衡以及集群容错 
- 请求过滤和包装



> org.apache.dubbo.rpc.protocol.AbstractInvoker#invoke

```java
@Override
public Result invoke(Invocation inv) throws RpcException {
    // if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed
    if (destroyed.get()) {
        logger.warn("Invoker for service " + this + " on consumer " + NetUtils.getLocalHost() + " is destroyed, "
                    + ", dubbo version is " + Version.getVersion() + ", this invoker should not be used any longer");
    }
    RpcInvocation invocation = (RpcInvocation) inv;
    invocation.setInvoker(this);
    if (CollectionUtils.isNotEmptyMap(attachment)) {
        invocation.addObjectAttachmentsIfAbsent(attachment);
    }

    Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();
    if (CollectionUtils.isNotEmptyMap(contextAttachments)) {
        /**
             * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,
             * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered
             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is
             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).
             */
        invocation.addObjectAttachments(contextAttachments);
    }

    invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

    AsyncRpcResult asyncResult;
    try {
        asyncResult = (AsyncRpcResult) doInvoke(invocation); // 
    } catch (InvocationTargetException e) { // biz exception
        Throwable te = e.getTargetException();
        if (te == null) {
            asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
        } else {
            if (te instanceof RpcException) {
                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);
            }
            asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, te, invocation);
        }
    } catch (RpcException e) {
        if (e.isBiz()) {
            asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
        } else {
            throw e;
        }
    } catch (Throwable e) {
        asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
    }
    RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
    return asyncResult;
}
```



> org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker#doInvoke
>
> 调用doInvoke方法发起远程请求。

```java
@Override
protected Result doInvoke(final Invocation invocation) throws Throwable {
    RpcInvocation inv = (RpcInvocation) invocation;
    final String methodName = RpcUtils.getMethodName(invocation);
    inv.setAttachment(PATH_KEY, getUrl().getPath());
    inv.setAttachment(VERSION_KEY, version);
	
    //获取一个客户端连接
    ExchangeClient currentClient;
    if (clients.length == 1) {
        currentClient = clients[0];
    } else {
        //如果有多个连接，则轮询返回
        currentClient = clients[index.getAndIncrement() % clients.length];
    }
    try {
        //是否是单向通信，默认为false
        boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
        int timeout = calculateTimeout(invocation, methodName);
        if (isOneway) {
            boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
            currentClient.send(inv, isSent);
            return AsyncRpcResult.newDefaultAsyncResult(invocation);
        } else {
            // 根据配置参数构建线程池
            ExecutorService executor = getCallbackExecutor(getUrl(), inv);
            // 使用client发起请求
            CompletableFuture<AppResponse> appResponseFuture =
                currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);
            // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter
            FutureContext.getContext().setCompatibleFuture(appResponseFuture);
            AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
            result.setExecutor(executor);
            return result;
        }
    } catch (TimeoutException e) {
        throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
    } catch (RemotingException e) {
        throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
    }
}
```

#### (12) ReferenceCountExchangeClient.request

currentClient还记得是一个什么对象吗？ 它实际是一个 `ReferenceCountExchangeClient(HeaderExchangeClient())` 所以它的调用链路是 `ReferenceCountExchangeClient->HeaderExchangeClient->HeaderExchangeChannel->(request方 法)` 最终，把构建好的RpcInvocation，组装到一个Request对象中进行传递

> org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient#request
>
> ```java
> @Override
> public CompletableFuture<Object> request(Object request, int timeout, ExecutorService executor) throws RemotingException {
>     return client.request(request, timeout, executor);
> }
> ```

- ReferenceCountExchangeClient 用来记录调用次数 
- HeaderExchangeClient 用来开启心跳机制、以及启动失败重连任务

#### (13) HeaderExchangeChannel.request

进入到HeaderExchangeChannel.request 来发起请求，这个类的主要职责就是和服务端进行数据交互

```java
@Override
public CompletableFuture<Object> request(Object request, int timeout, ExecutorService executor) throws RemotingException {
    if (closed) {
        throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!");
    }
    // create request.
    // 创建请求对象
    Request req = new Request();
    req.setVersion(Version.getProtocolVersion());
    req.setTwoWay(true);
    req.setData(request);
    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout, executor);
    try {
        // 发送请求
        channel.send(req);
    } catch (RemotingException e) {
        future.cancel();
        throw e;
    }
    return future;
}
```

AbstractPeer - >AbstractClient ->NettyChannel.send ,把数据包发送到服务端。