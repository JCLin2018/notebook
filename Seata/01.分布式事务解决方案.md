# 分布式事务解决方案

## 理论

### ACID

指数据库事务正确执行的四个基本要素：

1. 原子性（Atomicity）
2. 一致性（Consistency）
3. 隔离性（Isolation）
4. 持久性（Durability）

### CAP

CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

- 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
- 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
- 分区容忍性（Partition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

### BASE理论

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

- Basically Available（基本可用）
- Soft state（软状态）
- Eventually consistent（最终一致性）

## 什么是分布式事务？

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是由**Oracle Tuxedo**系统提出的**XA**分布式事务协议。

XA协议包含**两阶段提交（2PC）**和**三阶段提交（3PC）**两种实现，这里我们重点介绍两阶段提交的具体过程。

### 两阶段提交（2PC）

**正常流程**

第一阶段：

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/20201210145138.jpg)

在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。

在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。

当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

第二阶段：

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/20201210145148.jpg)

在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。

接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。

当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。

**异常处理流程**

第一阶段：

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/20201210145307.jpg)

第二阶段：

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/20201210145312.jpg)

在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。

于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。

#### XA两阶段提交的不足

1. 性能问题

   XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。

2. 协调者单点故障问题

   事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。

3. 丢失消息导致的不一致问题

   在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

### 三阶段提交（3PC）

三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞。三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。

**三阶段提交有两个改动点：**

1. 引入超时机制。同时在协调者和参与者中都引入超时机制。
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

第一阶段（CanCommit阶段）：

1. **协调者** 向 **参与者** 发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待 **参与者** 的响应。
2. **参与者** 接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务（**尝试获取数据库锁**），则返回Yes响应，并进入预备状态。否则反馈No

第二阶段（PreCommit阶段）：

分两种情况：

情况一：事务预提交（所有参与者均反馈YES时）

> 1. 协调者向所有参与者发出PreCommit请求，进入准备阶段。
> 2. 参与者收到PreCommit请求后，执行事务操作，但不提交事务。
> 3. 各参与者向协调者反馈Ack响应或No响应，并等待最终指令。

情况二：中断事务（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）

> 1. 协调者向所有参与者发出abort请求。
> 2. 无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。

第三阶段（DoCommit阶段）：

此阶段也存在两种情况：

情况一：提交事务：（所有参与者均反馈Ack响应时）

> 1. 如果协调者处于工作状态，则向所有参与者发出do Commit请求。
> 2. 参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。
> 3. 各参与者向协调者反馈Ack完成的消息。
> 4. 协调者收到所有参与者反馈的Ack消息后，即完成事务提交。

情况二：中断事务：（任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈时）

> 1. 如果协调者处于工作状态，向所有参与者发出abort请求。
> 2. 参与者使用阶段1中的Undo信息执行回滚操作，并释放整个事务期间占用的资源。
> 3. 各参与者向协调者反馈Ack完成的消息。
> 4. 协调者收到所有参与者反馈的Ack消息后，即完成事务中断。

#### 3PC的优点和缺陷

优点：降低了阻塞范围，引入了超时机制，在等待超时后协调者或参与者会中断事务。

缺陷：脑裂问题依然存在，即在参与者收到PreCommit请求后等待最终指令，如果此时协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。



### MQ事务

支持事务消息的MQ，其支持事务消息的方式采用类似于二阶段提交。

基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。

<img src="https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/95ea2af9b32a9e863cc0d9f6dd8b518c.jpeg" style="zoom: 200%;" />

**条件：**

a) 需要补偿逻辑

b) 业务处理逻辑需要幂等

**处理流程：**

c) 消费者向MQ发送half消息。

d) MQ Server将消息持久化后，向发送方ack确认消息发送成功。

e) 消费者开始执行事务逻辑。

f) 消费者根据本地事务执行结果向MQ Server提交二次确认或者回滚。

g) MQ Server收到commit状态则将half消息标记可投递状态。

h) 服务提供者收到该消息，执行本地业务逻辑。返回处理结果。

**优点：**

消息数据独立存储，降低业务系统与消息系统之间的耦合。

**缺点：**

一次消息发送需要两次网络请求(half消息 + commit/rollback)。

需要实现消息回查接口。

### TCC事务

TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

举个例子，假如 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用

1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些

缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。

### Sagas事务模型（最终一致性）

Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是：

**一、 事件/编排Choreography：没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。**

该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/fce2de01fd5777dcb5e87113fcf52d7f.jpeg)



**处理流程：**

订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。

支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。

库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。

货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。

最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。

假设库存服务在事务过程中失败了。进行回滚：

库存服务产生PRODUCT_OUT_OF_STOCK_EVENT

订购服务和支付服务会监听到上面库存服务的这一事件：

①支付服务会退款给客户。

②订单服务将订单状态设置为失败。

**优点：**事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。

**二、 命令/协调orchestrator：中央协调器负责集中处理事件的决策和业务逻辑排序。**

saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。

![5种分布式事务解决方案优缺点对比](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/Seata/4256e5e460603979abf01f868a66ee86.jpeg)



订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。

OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。

OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。

OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。

OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。

**优点：**

避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。

集中分布式事务的编排。

只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。

在添加新步骤时，事务复杂性保持线性，回滚更容易管理。

如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。