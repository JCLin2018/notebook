# RabbitMQ工作模型

## 1.什么是AMQP？

知道了什么是MQ， 为什么要使用MQ， 在讲Rabbit MQ之前， 我们有必要了解一下什么是A MSP协议。

下面我们讲讲什么是AM QP协议。

因为世界上第一个MQ TIB实现了发布订阅(Publish/Subscribe) 模型， 消息的生产者和消费者可以完全解耦，这个特性引起了电信行业特别是新闻机构的注意。1994年路透社收购了Teknekron。

TIB的成功马上引起了业界大佬IBM的注意， 他们研发了自己的IBM MQ(IBM Wesphere —— 人民银行主导研发的二代支付系统用的就是IBMＭQ) 。后面微软也加入了这场战斗， 研发了MSMQ。这个时候， 每个厂商的产品是孤立的， 大家都有自己的技术壁垒。比如一个应用订阅了IBM ＭQ的消息， 如果有要订阅MSMQ的消息， 因为协议、API不同， 又要重复去实现。为什么大家都不愿意去创建标准接口， 来实现不同的ＭQ产品的互通呢?跟现在微信里面不能打开淘宝页面是一个道理(商业竞争)。

JDBC协议大家非常熟悉吧?J2EE制定了JDBC的规范， 那么那么各个数据库厂商自己去实现协议， 提供jar包， 在Java里面就可以使用相同的API做操作不同的数据库了。MQ产品的问题也是一样的， 2001年的时候， SUN公司发布了JMS规范， 它想要在各大厂商的MQ上面统一包装一层Java的规范， 大家都只需要针对API编程就可以了，不需要关注使用了什么样的消息中间件， 只要选择合适的MQ驱动。但是JMS只适用于Java语言， 它是跟语言绑定的， 没有从根本上解决这个问题(只是一个API) 。

所以在2004年， 几个大公司开始开发AM QP标准。2006年， AMQP规范发布了。AMQP的全称是：Advanced Message Queuing Protocol， 本质上是一种进程间传递异步消息的网络协议。它是跨语言和跨平台的，不管是什么样的MQ服务器，不管是什么语言的客户端， 只要遵循AMQP协议， 就可以实现消息的交互。真正地促进了消息队列的繁荣发展。

AMQP是一个工作于应用层的协议， 最新的版本是1.0版本。可以使用WireShark等工具对Rabbit MQ通信的AM QP协议进行抓包。

![image-20210505234622973](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/rabbitmq/20210505234623.png)

既然它是一种协议或者规范， 不是Rabbit MQ专门设计的， 市面上肯定还有很多其他实现了AM QP协议的消息中间件， 比如：OpenAMQ、Apache Qpid、Redhat、Enterprise MRG、AMQP Infrastructure、OMQ、Zyre。



## 2.RabbitMQ简介

官网 https://www.rabbitmq.com/getstarted.html

2007年， Rabbit技术公司基于AM QP开发了Rabbit MQ 1.0。为什么要用Erlang语言呢?因为Erlang是作者Matthias擅长的开发语言。第二个就是Erlang是为电话交换机编写的语言，天生适合分布式和高并发。

为什么要取Rabbit Technologies这个名字呢?因为兔子跑得很快， 而且繁殖起来很疯狂。

从最开始用在金融行业里面， 现在Rabbit MQ已经在世界各地的公司中遍地开花。国内的绝大部分大厂都在用RabbitMQ， 包括头条， 美团， 滴滴(TMD) ， 去哪儿， 艺龙，淘宝也有用。

Rabbit MQ和Spring家族属于同一家公司：Pivotal。

当然， 除了AM QP之外， Rabbit MQ支持多种协议， STOMP、MQTT、HTTP、WebSocket。

### 2.1工作模型

由于RabbitMQ实现了APQP协议，所以RabbitMQ的工作模型也是基于AMQP的。

![image-20210505235114514](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/rabbitmq/20210505235114.png)

1. Broker

   MQ服务器

2. Connection

   生产者、消费者与Broker之间建立一个TCP长连接

3. Channel

   如果所有的生产者发送消息和消费者接收消息， 都直接创建和释放TCP长连接的话，对于Broker来说肯定会造成很大的性能损耗， 也会浪费时间。

   所以在AM QP里面引入了Channel的概念， 它是一个虚拟的连接。我们把它翻译成通道， 或者消息信道。这样我们就可以在保持的TCP长连接里面去创建和释放Channel， 大大了减少了资源消耗。

   不同的Channel是相互隔离的， 每个Channel都有自己的编号。对于每个客户端线程来说， Channel就没必要共享了， 各自用自己的Channel。

   另外一个需要注意的是， Channel是RabbitMQ原生API里面的最重要的编程接口，也就是说我们定义交换机、队列、绑定关系， 发送消息， 消费消息， 调用的都是Channel接口上的方法。

4. Queue

   连接到Broker以后， 就可以收发消息了。

   在Broker上有一个对象用来存储消息， 在Rabbit MQ里面这个对象叫做Queue。实际上Rabbit MQ是用数据库来存储消息的， 这个数据库跟Rabbit MQ一样是用Erlang开发的， 名字叫Mnesia。

   队列也是生产者和消费者的纽带，生产者发送的消息到达队列，在队列中存储。消费者从队列消费消息。

5. Consumer
   消息到底是Broker推送给消费者的?还是消费者主动获取的?消费者消费消息有两种模式。

   - 一种是Pull模式， 对应的方法是basic Get。消息存放在服务端， 只有消费者主动获取才能拿到消息。如果每隔一段时间获取一次消息，消息的实时性会降低。但是好处是可以根据自己的消费能力决定获取消息的频率。

   - 另一种是Push模式， 对应的方法是basic Consume， 只要生产者发消息到服务器，就马上推送给消费者，消息保存在客户端，实时性很高，如果消费不过来有可能会造成消息积压。Spring AM QP是push方式， 通过事件机制对队列进行监听， 只要有消息到达队列，就会触发消费消息的方法。

   RabbitMQ中pull和push都有实现。kafka和Rocket MQ只有pull。

   由于队列有FIFO的特性， 只有确定前一条消息被消费者接收之后， Broker才会把这条消息从数据库删除，继续投递下一条消息。

   一个消费者是可以监听多个队列的，一个队列也可以被多个消费者监听。

   但是在生产环境中，我们一般是建议一个消费者只处理一个队列的消息。如果需要提升处理消息的能力，可以增加多个消费者。这个时候消息会在多个消费者之间轮询。

6. Exchange

   现在我们来思考一个问题，如果要把一条消息发送给多个队列，被多个消费者消费，应该怎么做?生产者是不是必须要调用多次basic Publish的方法， 依次发送给多个队列?就像消息推送的这种场景，有成千上万个队列的时候，对生产者来说压力太大了。

   有没有更好的办法呢?其实， Rabbit MQ已经为我们考虑到了这一点， 它设计了一个帮我们路由消息的组件， 叫做Exchange。

   也就是说， 不管有多少个队列需要接收消息， 我都只需要发送到Exchange就OK了， 由它帮我来分发。Exchange是不会存储消息的， 它只做一件事情， 根据规则分发消息。

   那么， Exchange和这些需要接收消息的队列必须建立一个绑定关系， 并且为每个队列指定一个特殊的标识。

   Exchange和队列是多对多的绑定关系， 也就说， 一个交换机的消息一个路由给多个队列，一个队列也可以接收来自多个交换机的消息。

   绑定关系建立好之后， 生产者发送消息到Exchange， 也会携带一个特殊的标识。当这个标识跟绑定的标识匹配的时候，消息就会发给一个或者多个符合规则的队列。

7. Vhost

   我们每个需要实现基于Rabbit MQ的异步通信的系统， 都需要在Broker上创建自己要用到的交换机、队列和它们的绑定关系。如果某个业务系统不想跟别人混用一个Broker， 怎么办?再采购一台硬件服务器单独安装一个Rabbit MQ服务?这种方式成本太高了。在同一个硬件服务器上安装多个Rabbit MQ的服务呢?比如再运行一个5673的端口?

   没有必要这样做， 因为Rabbit MQ也考虑到了这一点， 设计了虚拟主机VHOST。

   VHOST除了可以提高硬件资源的利用率之外， 还可以实现资源的隔离和权限的控制。它的作用类似于编程语言中的namespace和package， 不同的VHOST中可以有同名的Exchange和Queue， 它们是完全透明的。

   这个时候， 我们可以为不同的业务系统创建专属于他们自己的VHOST， 然后再为他们创建专属的用户， 给用户分配对应的VHOST的权限。比如给风控系统的用户分配风控系统的VHOST的权限， 这个用户可以访问里面的交换机和队列。给超级管理员分配所有
   VHOST的权限。

   我们安装Rabbit MQ的时候会自带一个默认的VHOST， 名字是“/”。

### 2.2路由方式

#### 2.2.1Direct直连



#### 2.2.2Topic主题



#### 2.2.3Fanout广播



#### 2.2.4Headers





## 3.基本使用

### 3.1安装

### 3.2Java API编程

### 3.3UI管理界面



## 4.RabbitMQ进阶知识

### 4.1怎么实现订单延迟关闭？



#### 4.1.1业务场景

#### 4.1.2Message TTL（Time To Live）

#### 4.1.3死信

#### 4.1.4延迟队列的其他实现



### 4.2服务端流控（Flow Control）



#### 4.2.1队列长度

#### 4.2.2内存控制

#### 4.2.3磁盘控制



### 4.3消费端限流



## 5.Spring AMQP



### 5.1Spring集成RabbitMQ配置解读

### 5.2SpringAMQP核心对象

### 5.3.SpringBoot集成RabbitMQ



## 6.RabbitMQ特性总结

























