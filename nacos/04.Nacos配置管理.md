# Nacos配置管理原理分析

## 基于dataId为yaml的文件扩展配置

spring-cloud-starter-alibaba-nacos-config默认支持的文件格式是properties, 如果我们想用其他格式 的文件，可以只需要完成以下两步：

1. 在应用的 bootstrap.properties 配置文件中显示的声明 dataId 文件扩展名。如下所示 bootstrap.properties

   ```properties
   spring.cloud.nacos.config.file-extension=yaml
   ```

2. 在Nacos控制台，修改配置文件的类型，改成yaml

## 针对profile粒度配置

spring-cloud-starter-alibaba-nacos-config 在加载配置的时候，不仅仅加载了以 dataId 为 `${spring.application.name}.${file-extension:properties}` 为前缀的基础配置，还加载了 dataId为 `${spring.application.name}-${profile}.${file-extension:properties}` 的基础配 置。在日常开发中如果遇到多套环境下的不同配置，可以通过Spring 提供的 `${spring.profiles.active}` 这个配置项来配置。

- 在bootstrap.properties中添加profile

  ```properties
  spring.profiles.active=develop
  ```

- Nacos 上新增一个dataId为：nacos-config-develop.yaml的基础配置，如下所示：

  ```txt
  Data ID: nacos-dubbo-provider-develop.yaml
  Group : DEFAULT_GROUP
  配置格式: YAML
  配置内容: current.env: develop-env
  ```

如果需要切换到生产环境，只需要更改 ${spring.profiles.active} 参数配置即可。如下所示：

```properties
spring.profiles.active=product
```

> 此案例中我们通过 spring.profiles.active= 的方式写死在配置文件中，而在真正的项目实施 过程中这个变量的值是需要不同环境而有不同的值。这个时候通常的做法是通过 `-Dspring.profiles.active=` 参数指定其配置来达到环境间灵活的切换。

## Nacos 中的Namespace和Group

在nacos中提供了namespace和group命名空间和分组的机制。，它是Nacos提供的一种数据模型，也 就是我们要去定位到一个配置，需要基于namespace- > group ->dataid来实现。 

namespace可以解决多环境以及多租户数据的隔离问题。比如在多套环境下，可以根据指定环境创建 不同的namespace，实现多环境隔离。或者在多租户的场景中，每个用户可以维护自己的 namespace，实现每个用户的配置数据和注册数据的隔离。

group是分组机制，它的纬度是实现服务注册信息或者DataId的分组管理机制，对于group的用法，没 有固定的规则，它也可以实现不同环境下的分组，也可以实现同一个应用下不同配置类型或者不同业务 类型的分组。

> 官方建议是，namespace用来区分不同环境，group可以专注在业务层面的数据分组。实际上在 使用过程中，最重要的是提前定要统一的口径和规定，避免不同的项目团队混用导致后期维护混 乱的问题。

### 自定义namespace

在没有明确指定 `${spring.cloud.nacos.config.namespace}` 配置的情况下， 默认使用的是 Nacos 上 Public 这个namespae。如果需要使用自定义的命名空间，可以通过以下配置来实现：

```properties
spring.cloud.nacos.config.namespace=b3404bc0-d7dc-4855-b519-570ed34b62d7
```

> 该配置必须放在 bootstrap.properties 文件中。此外 spring.cloud.nacos.config.namespace 的值是 namespace 对应的 id，id 值可以在 Nacos 的控制台获取。并且在添加配置时注意不要选择其他的 namespae，否则将会导致读取不到正确 的配置。

### 自定义group

在没有明确指定 `${spring.cloud.nacos.config.group}` 配置的情况下， 默认使用的是 DEFAULT_GROUP 。如果需要自定义自己的 Group，可以通过以下配置来实现：

```properties
spring.cloud.nacos.config.group=DEVELOP_GROUP
```

> 该配置必须放在 bootstrap.properties 文件中。并且在添加配置时 Group 的值一定要和 spring.cloud.nacos.config.group 的配置值一致

### 自定义扩展的DataId

Spring Cloud Alibaba Nacos Config 从 0.2.1 版本后，可支持自定义 Data Id 的配置。关于这部分详细 的设计可参考 [这里](https://github.com/alibaba/spring-cloud-alibaba/issues/141)。 一个完整的配置案例如下所示：

```properties
spring.application.name=opensource-service-provider
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# config external configuration

# 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新
spring.cloud.nacos.config.extension-configs[0].data-id=ext-configcommon01.properties

# 2、Data Id 不在默认的组，不支持动态刷新
spring.cloud.nacos.config.extension-configs[1].data-id=ext-configcommon02.properties
spring.cloud.nacos.config.extension-configs[1].group=GLOBALE_GROUP

# 3、Data Id 既不在默认的组，也支持动态刷新
spring.cloud.nacos.config.extension-configs[2].data-id=ext-configcommon03.properties
spring.cloud.nacos.config.extension-configs[2].group=REFRESH_GROUP
spring.cloud.nacos.config.extension-configs[2].refresh=true
```

可以看到: 

- 通过 `spring.cloud.nacos.config.extension-configs[n].data-id` 的配置方式来支持多个 Data Id 的配置。
- 通过 `spring.cloud.nacos.config.extension-configs[n].group` 的配置方式自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。
- 通过 `spring.cloud.nacos.config.extension-configs[n].refresh` 的配置方式来控制该 Data Id 在配置变更时，是否支持应用中可动态刷新， 感知到最新的配置值。默认是不支持的。

> 多个 Data Id 同时配置时，他的优先级关系是 `spring.cloud.nacos.config.extensionconfigs[n].data-id` 其中 n 的值越大，优先级越高。

>Note `spring.cloud.nacos.config.extension-configs[n].data-id` 的值必须带文件扩展 名，文件扩展名既可支持 properties，又可以支持 yaml/yml。 此时 `spring.cloud.nacos.config.file-extension` 的配置对自定义扩展配置的 Data Id 文件扩展 名没有影响。

通过自定义扩展的 Data Id 配置，既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个 配置文件。 

为了更加清晰的在多个应用间配置共享的 Data Id ，你可以通过以下的方式来配置： 

通过自定义扩展的 Data Id 配置，既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个 配置文件。 

为了更加清晰的在多个应用间配置共享的 Data Id ，你可以通过以下的方式来配置：

```properties
# 配置支持共享的 Data Id
spring.cloud.nacos.config.shared-configs[0].data-id=common.yaml

# 配置 Data Id 所在分组，缺省默认 DEFAULT_GROUP
spring.cloud.nacos.config.shared-configs[0].group=GROUP_APP1

# 配置Data Id 在配置变更时，是否动态刷新，缺省默认 false
spring.cloud.nacos.config.shared-configs[0].refresh=true
```

可以看到：

- 通过 `spring.cloud.nacos.config.shared-configs[n].data-id` 来支持多个共享 Data Id 的配 置。 
- 通过 `spring.cloud.nacos.config.shared-configs[n].group` 来配置自定义 Data Id 所在的 组，不明确配置的话，默认是 DEFAULT_GROUP。 
- 通过 `spring.cloud.nacos.config.shared-configs[n].refresh` 来控制该Data Id在配置变更时，是否支持应用中动态刷新，默认false。

### 配置的优先级

Spring Cloud Alibaba Nacos Config 目前提供了三种配置能力从 Nacos 拉取相关的配置。 

- A: 通过 spring.cloud.nacos.config.shared-configs[n].data-id 支持多个共享 Data Id 的 配置 
- B: 通过 spring.cloud.nacos.config.extension-configs[n].data-id 的方式支持多个扩展 Data Id 的配置 
- C: 通过内部相关规则(应用名、应用名+ Profile )自动生成相关的 Data Id 配置 

当三种方式共同使用时，他们的一个优先级关系是:A < B < C

## Spring Cloud Nacos 配置管理 源码分析

在spring cloud netflix的课程中，我们分析了Environment，这个是非常重要的类，他负责管理spring 的运行相关的配置信息，其中就包含application.properties。 

而在Spring Cloud中，如果集成Nacos作为配置中心的话，那么意味着这部分配置是属于远程配置，也会作为配置源保存到Environment中，这样我们才能通过@value注解来注入配置中的属性。 

从之前的学习Config的源码中，我们知道Environment中所有外部化配置，针对不同类型的配置都会有与之对应的PropertySource，比如（SystemEnvironmentPropertySource、 CommandLinePropertySource）。以及PropertySourcesPropertyResolver来进行解析。 

那NacosClient在启动的时候，必然也会需要从远程服务器上获取配置加载到Environment中，这样才能使得应用程序通过@Value进行属性的注入，而且我们一定可以猜测到的是，这块的工作一定又和 spring中某个机制有关系。

### SpringApplication.run

在spring boot项目启动时，有一个prepareContext的方法，它会回调所有实现了 `ApplicationContextInitializer` 的实例，来做一些初始化工作。

> org.springframework.boot.SpringApplication#run(java.lang.String...)

```java
public ConfigurableApplicationContext run(String... args) {
    // 省略代码...
    prepareContext(context, environment, listeners, applicationArguments, printedBanner);
    // 省略代码...
    return context;
}

private void prepareContext(ConfigurableApplicationContext context, 
                            ConfigurableEnvironment environment, 
                            SpringApplicationRunListeners listeners, 
                            ApplicationArguments applicationArguments, 
                            Banner printedBanner) {
    // 省略代码...
    applyInitializers(context);
    // 省略代码...
}

protected void applyInitializers(ConfigurableApplicationContext context) {
    
    for (ApplicationContextInitializer initializer : getInitializers()) {
        Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class);
        
        Assert.isInstanceOf(requiredType, context, "Unable to call initializer.");
        initializer.initialize(context); // 执行初始化...
    }
}
```

### PropertySourceBootstrapConfiguration.initialize

PropertySourceBootstrapConfiguration 实现了 ApplicationContextInitializer 接口，其目的就是在应用程序上下文初始化的时候做一些额外的操作.

根据默认的 AnnotationAwareOrderComparator 排序规则对propertySourceLocators数组进行排序

获取运行的环境上下文ConfigurableEnvironment

遍历propertySourceLocators时 

- 调用 locate 方法，传入获取的上下文environment 
- 将source添加到PropertySource的链表中 
- 设置source是否为空的标识标量empty

source不为空的情况，才会设置到environment中 

- 返回Environment的可变形式，可进行的操作如addFirst、addLast 
- 移除propertySources中的bootstrapProperties 
- 根据config server覆写的规则，设置propertySources 
- 处理多个active profiles的配置信息

> org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration#initialize

```java
@Override
public void initialize(ConfigurableApplicationContext applicationContext) {
    List<PropertySource<?>> composite = new ArrayList<>();
    // 对propertySourceLocators数组进行排序，根据默认的AnnotationAwareOrderComparator
    AnnotationAwareOrderComparator.sort(this.propertySourceLocators);
    boolean empty = true;
    // 获取运行的环境上下文
    ConfigurableEnvironment environment = applicationContext.getEnvironment();
    for (PropertySourceLocator locator : this.propertySourceLocators) {
        // 回调所有实现PropertySourceLocator接口实例的locate方法，
        Collection<PropertySource<?>> source = locator.locateCollection(environment);
        if (source == null || source.size() == 0) {
            continue;
        }
        List<PropertySource<?>> sourceList = new ArrayList<>();
        for (PropertySource<?> p : source) {
            sourceList.add(new BootstrapPropertySource<>(p));
        }
        logger.info("Located property source: " + sourceList);
        composite.addAll(sourceList); // 将source添加到数组
        empty = false;  // 表示propertysource不为空
    }
    // 只有propertysource不为空的情况，才会设置到environment中
    if (!empty) {
        MutablePropertySources propertySources = environment.getPropertySources();
        String logConfig = environment.resolvePlaceholders("${logging.config:}");
        LogFile logFile = LogFile.get(environment);
        for (PropertySource<?> p : environment.getPropertySources()) {
            if (p.getName().startsWith(BOOTSTRAP_PROPERTY_SOURCE_NAME)) {
                propertySources.remove(p.getName());
            }
        }
        insertPropertySources(propertySources, composite);
        reinitializeLoggingSystem(environment, logConfig, logFile);
        setLogLevels(applicationContext, environment);
        handleIncludedProfiles(environment);
    }
}
```

### PropertySourceLoader.locateCollection

这个方法会调用子类的locate方法，来获得一个PropertySource，然后将PropertySource集合返回。接 着它会调用 `ConfigServicePropertySourceLocator` 的locate方法。

> org.springframework.cloud.bootstrap.config.PropertySourceLocator

```java
public interface PropertySourceLocator {

	default Collection<PropertySource<?>> locateCollection(Environment environment) {
		return locateCollection(this, environment);
	}

	static Collection<PropertySource<?>> locateCollection(PropertySourceLocator locator,
			Environment environment) {
        // locator 对象是 NacosPropertySourceLocator 对象
		PropertySource<?> propertySource = locator.locate(environment);
		if (propertySource == null) {
			return Collections.emptyList();
		}
		if (CompositePropertySource.class.isInstance(propertySource)) {
			Collection<PropertySource<?>> sources = ((CompositePropertySource) propertySource)
					.getPropertySources();
			List<PropertySource<?>> filteredSources = new ArrayList<>();
			for (PropertySource<?> p : sources) {
				if (p != null) {
					filteredSources.add(p);
				}
			}
			return filteredSources;
		}
		else {
			return Arrays.asList(propertySource);
		}
	}

}
```

### NacosPropertySourceLocator.locate

这个就是Nacos 配置中心加载的的关键实现了，分别调用三个方法来加载配置

> NAOCOS配置加载顺序：共享配置 --> 扩展配置 --> 自身配置（后面优先级高） , 这三个配置在前 面的内容中我们已经讲过了
>
> com.alibaba.cloud.nacos.client.NacosPropertySourceLocator#locate

```java
@Override
public PropertySource<?> locate(Environment env) {
    nacosConfigProperties.setEnvironment(env);
    ConfigService configService = nacosConfigManager.getConfigService();

    if (null == configService) {
        log.warn("no instance of config service found, can't load config from nacos");
        return null;
    }
    long timeout = nacosConfigProperties.getTimeout();
    nacosPropertySourceBuilder = new NacosPropertySourceBuilder(configService,
                                                                timeout);
    String name = nacosConfigProperties.getName();

    String dataIdPrefix = nacosConfigProperties.getPrefix();
    if (StringUtils.isEmpty(dataIdPrefix)) {
        dataIdPrefix = name;
    }

    if (StringUtils.isEmpty(dataIdPrefix)) {
        dataIdPrefix = env.getProperty("spring.application.name");
    }
	// 创建复合数据源对象
    CompositePropertySource composite = new CompositePropertySource(NACOS_PROPERTY_SOURCE_NAME);
    
	// 加载共享配置
    loadSharedConfiguration(composite);
    // 加载扩展配置
    loadExtConfiguration(composite);
    // 加载自身配置
    loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env);

    return composite;
}

// 加载共享配置
private void loadSharedConfiguration(CompositePropertySource compositePropertySource) {
    List<NacosConfigProperties.Config> sharedConfigs = nacosConfigProperties.getSharedConfigs();
    if (!CollectionUtils.isEmpty(sharedConfigs)) {
        checkConfiguration(sharedConfigs, "shared-configs");
        loadNacosConfiguration(compositePropertySource, sharedConfigs);
    }
}

// 加载扩展配置
private void loadExtConfiguration(CompositePropertySource compositePropertySource) {
    List<NacosConfigProperties.Config> extConfigs = nacosConfigProperties.getExtensionConfigs();
    if (!CollectionUtils.isEmpty(extConfigs)) {
        checkConfiguration(extConfigs, "extension-configs");
        loadNacosConfiguration(compositePropertySource, extConfigs);
    }
}

private void loadNacosConfiguration(final CompositePropertySource composite,
                                    List<NacosConfigProperties.Config> configs) {
		for (NacosConfigProperties.Config config : configs) {
			String dataId = config.getDataId();
			String fileExtension = dataId.substring(dataId.lastIndexOf(DOT) + 1);
			loadNacosDataIfPresent(composite, dataId, config.getGroup(), fileExtension, config.isRefresh());
		}
	}
```

### loadApplicationConfiguration

我们可以先不管加载共享配置、扩展配置的方法，最终本质上都是去远程服务上读取配置，只是传入的参数不一样。

- fileExtension，表示配置文件的扩展名 
- nacosGroup表示分组 
- 加载 dataId=项目名称 的配置 
- 加载 dataId=项目名称+扩展名 的配置 
- 遍历当前配置的激活点（profile），分别循环加载带有profile的dataid配置

```java
private void loadApplicationConfiguration(
    // 复合配置源，前面加载的共享配置、扩展配置都存储在 这个对象中
    CompositePropertySource compositePropertySource,  
    String dataIdPrefix,
    NacosConfigProperties properties, 
    Environment environment) {
    
    // 获取配置文件扩展名
    String fileExtension = properties.getFileExtension();
    // 获取分组名称
    String nacosGroup = properties.getGroup();
    // load directly once by default
    loadNacosDataIfPresent(compositePropertySource, dataIdPrefix, nacosGroup, fileExtension, true);
    // load with suffix, which have a higher priority than the default
    loadNacosDataIfPresent(compositePropertySource, dataIdPrefix + DOT + fileExtension, nacosGroup, fileExtension, true);
    // Loaded with profile, which have a higher priority than the suffix
    for (String profile : environment.getActiveProfiles()) {
        String dataId = dataIdPrefix + SEP1 + profile + DOT + fileExtension;
        loadNacosDataIfPresent(compositePropertySource, dataId, nacosGroup, fileExtension, true);
    }

}
```

### loadNacosDataIfPresent

调用 `loadNacosPropertySource` 加载存在的配置信息。 

把加载之后的配置属性保存到CompositePropertySource中。

```java
private void loadNacosDataIfPresent(final CompositePropertySource composite,
                                    final String dataId, 
                                    final String group, 
                                    String fileExtension,
                                    boolean isRefreshable) {
    
    if (null == dataId || dataId.trim().length() < 1) {
        return;
    }
    if (null == group || group.trim().length() < 1) {
        return;
    }
    NacosPropertySource propertySource = this.loadNacosPropertySource(dataId, group, fileExtension, isRefreshable);
    this.addFirstPropertySource(composite, propertySource, false);
}
```

### loadNacosPropertySource

```java
private NacosPropertySource loadNacosPropertySource(final String dataId,
                                                    final String group, 
                                                    String fileExtension, // 配置文件后缀
                                                    boolean isRefreshable) {// 支持刷新，默认true
    
    if (NacosContextRefresher.getRefreshCount() != 0) {
        if (!isRefreshable) { // 是否支持自动刷新，// 如果不支持自动刷新配置，则自动从缓存获取返回
            return NacosPropertySourceRepository.getNacosPropertySource(dataId, group);
        }
    }
    // 构造器从配置中心获取数据
    return nacosPropertySourceBuilder.build(dataId, group, fileExtension, isRefreshable);
}
```

### nacosPropertySourceBuilder.build

> com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#build

```java
NacosPropertySource build(String dataId, 
                          String group, 
                          String fileExtension,
                          boolean isRefreshable) {
    
    // 调用loadNacosData加载远程数据
    Map<String, Object> p = loadNacosData(dataId, group, fileExtension);
    // 返回一个源数据Map，使用NacosPropertySource进行包装
    NacosPropertySource nacosPropertySource = new NacosPropertySource(group, dataId, p, new Date(), isRefreshable);
    
    // 返回Nacos属性源
    NacosPropertySourceRepository.collectNacosPropertySource(nacosPropertySource);
    return nacosPropertySource;
}
```

### loadNacosData

加载Nacos的数据。

> com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#loadNacosData

```java
private Map<String, Object> loadNacosData(String dataId, 
                                          String group,
                                          String fileExtension) {
    
    String data = null;
    try {
        // http远程访问配置中心，获取配置数据 例：data="pro.name=JC.lin\npro.test=jjjjj\npxa.aaa=bbb"
        data = configService.getConfig(dataId, group, timeout);
        if (StringUtils.isEmpty(data)) {  // 如果为空，则提示日志
            log.warn("Ignore the empty nacos configuration and get it based on dataId[{}] & group[{}]", dataId, group);
            
            return EMPTY_MAP;
        }
        if (log.isDebugEnabled()) {
            log.debug(String.format("Loading nacos data, dataId: '%s', group: '%s', data: %s", dataId, group, data));
            
        }
        // 根据扩展名进行数据的解析
        Map<String, Object> dataMap = NacosDataParserHandler.getInstance().parseNacosData(data, fileExtension);
        return dataMap == null ? EMPTY_MAP : dataMap;
    }
    catch (NacosException e) {
        log.error("get data from Nacos error,dataId:{}, ", dataId, e);
    }
    catch (Exception e) {
        log.error("parse data from Nacos error,dataId:{},data:{},", dataId, data, e);
    }
    return EMPTY_MAP;
}
```

> NacosDataParserHandler.getInstance().parseNacosData -> parser.parseNacosData -> this.doParse(data)
>
> 下面是以Properties文件解析为例

```java
public class NacosDataPropertiesParser extends AbstractNacosDataParser {

	private static final Logger log = LoggerFactory.getLogger(NacosDataPropertiesParser.class);

	public NacosDataPropertiesParser() {
		super("properties");
	}

	@Override
	protected Map<String, Object> doParse(String data) throws IOException {
		Map<String, Object> result = new LinkedHashMap<>();

		try (BufferedReader reader = new BufferedReader(new StringReader(data))) {
            // 读取一行，进行解析
			for (String line = reader.readLine(); line != null; line = reader.readLine()) {
				String dataLine = line.trim();
				if (StringUtils.isEmpty(dataLine) || dataLine.startsWith("#")) {
					continue;
				}
				int index = dataLine.indexOf("=");
				if (index == -1) {
					log.warn("the config data is invalid {}", dataLine);
					continue;
				}
				result.put(dataLine.substring(0, index), dataLine.substring(index + 1));
			}
		}
		return result;
	}

}
```



### getConfigInner 

> configService.getConfig -> com.alibaba.nacos.client.config.NacosConfigService#getConfigInner

继续往下跟踪，最终进入到getConfigInner方法，主要有几个逻辑 

- 先从本地磁盘中加载配置，因为应用在启动时，会加载远程配置缓存到本地，如果本地文件的内容不为空，直接返回。 
- 如果本地文件的内容为空，则调用worker.getServerConfig加载远程配置 
- 如果出现异常，则调用本地快照文件加载配置

> com.alibaba.nacos.client.config.NacosConfigService#getConfigInner

```java
private String getConfigInner(String tenant, String dataId, String group, long timeoutMs) throws NacosException {
    group = null2defaultGroup(group);
    ParamUtils.checkKeyParam(dataId, group);
    ConfigResponse cr = new ConfigResponse();

    cr.setDataId(dataId);
    cr.setTenant(tenant);
    cr.setGroup(group);

    // 优先使用本地配置
    String content = LocalConfigInfoProcessor.getFailover(agent.getName(), dataId, group, tenant);
    if (content != null) {
        LOGGER.warn("[{}] [get-config] get failover ok, dataId={}, group={}, tenant={}, config={}", 
                    agent.getName(),
                    dataId, 
                    group, 
                    tenant, 
                    ContentUtils.truncateContent(content));
        
        cr.setContent(content);
        configFilterChainManager.doFilter(null, cr);
        content = cr.getContent();
        return content;
    }
	
    // 加载远程配置
    try {
        String[] ct = worker.getServerConfig(dataId, group, tenant, timeoutMs);
        cr.setContent(ct[0]);

        configFilterChainManager.doFilter(null, cr);
        content = cr.getContent();

        return content;
    } catch (NacosException ioe) {
        if (NacosException.NO_RIGHT == ioe.getErrCode()) {
            throw ioe;
        }
        LOGGER.warn("[{}] [get-config] get from server error, dataId={}, group={}, tenant={}, msg={}", 
                    agent.getName(), 
                    dataId, 
                    group, 
                    tenant, 
                    ioe.toString());
    }

    LOGGER.warn("[{}] [get-config] get snapshot ok, dataId={}, group={}, tenant={}, config={}", 
                agent.getName(), 
                dataId, 
                group, 
                tenant, 
                ContentUtils.truncateContent(content));
    
    // 读取快照文件
    content = LocalConfigInfoProcessor.getSnapshot(agent.getName(), dataId, group, tenant);
    cr.setContent(content);
    configFilterChainManager.doFilter(null, cr);
    content = cr.getContent();
    return content;
}
```

### worker.getServerConfig

通过agent.httpGet发起http请求，获取远程服务的配置。

> com.alibaba.nacos.client.config.impl.ClientWorker#getServerConfig

```java
public String[] getServerConfig(String dataId, String group, String tenant, long readTimeout)
    throws NacosException {
    String[] ct = new String[2];
    if (StringUtils.isBlank(group)) {
        group = Constants.DEFAULT_GROUP;
    }

    HttpResult result = null;
    try {
        List<String> params = null;
        if (StringUtils.isBlank(tenant)) {
            params = new ArrayList<String>(Arrays.asList("dataId", dataId, "group", group));
        } else {
            params = new ArrayList<String>(Arrays.asList("dataId", dataId, "group", group, "tenant", tenant));
        }
        // 调用 /configs api接口获取Nacos配置
        result = agent.httpGet(Constants.CONFIG_CONTROLLER_PATH, null, params, agent.getEncode(), readTimeout);
    } catch (IOException e) {
        String message = String.format(
            "[%s] [sub-server] get server config exception, dataId=%s, group=%s, tenant=%s", agent.getName(),
            dataId, group, tenant);
        LOGGER.error(message, e);
        throw new NacosException(NacosException.SERVER_ERROR, e);
    }

    switch (result.code) {
        case HttpURLConnection.HTTP_OK: // 成功 
            // 将配置文件存储到快照文件
            LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, result.content);
            ct[0] = result.content; // 配置内容 例："pro.name=JC.lin\npro.test=jjjjj\npxa.aaa=bbb"
            if (result.headers.containsKey(CONFIG_TYPE)) {
                ct[1] = result.headers.get(CONFIG_TYPE).get(0); // 配置类型，例："properties"
            } else {
                ct[1] = ConfigType.TEXT.getType();
            }
            return ct;
            
        case HttpURLConnection.HTTP_NOT_FOUND: //404
            
            LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, null);
            return ct;
            
        case HttpURLConnection.HTTP_CONFLICT: { // 409
            
            LOGGER.error("[{}] [sub-server-error] get server config being modified concurrently, dataId={}, group={}, " + "tenant={}", agent.getName(), dataId, group, tenant);
            throw new NacosException(NacosException.CONFLICT, "data being modified, dataId=" + dataId + ",group=" + group + ",tenant=" + tenant);
            
        }
            
        case HttpURLConnection.HTTP_FORBIDDEN: { // 403
            
            LOGGER.error("[{}] [sub-server-error] no right, dataId={}, group={}, tenant={}", agent.getName(), dataId, group, tenant);
            throw new NacosException(result.code, result.content);
            
        }
            
        default: {
            
            LOGGER.error("[{}] [sub-server-error]  dataId={}, group={}, tenant={}, code={}", agent.getName(), dataId, group, tenant, result.code);
            throw new NacosException(result.code, "http error, code=" + result.code + ",dataId=" + dataId + ",group=" + group + ",tenant=" + tenant);
            
        }
    }
}
```

### 客户端配置的动态感知

> NacosConfigService的创建过程：
>
> com.alibaba.cloud.nacos.NacosConfigAutoConfiguration#nacosConfigManager ->
>
> com.alibaba.cloud.nacos.NacosConfigManager#createConfigService ->
>
> com.alibaba.nacos.api.NacosFactory#createConfigService  -> 
>
> com.alibaba.nacos.api.config.ConfigFactory#createConfigService -> 
>
> ```java
> public static ConfigService createConfigService(Properties properties) throws NacosException {
>     try {
>         // 利用反射调用NacosConfigService的构造方法
>         Class<?> driverImplClass = Class.forName("com.alibaba.nacos.client.config.NacosConfigService");
>         Constructor constructor = driverImplClass.getConstructor(Properties.class);
>         ConfigService vendorImpl = (ConfigService) constructor.newInstance(properties);
>         return vendorImpl;
>     } catch (Throwable e) {
>         throw new NacosException(NacosException.CLIENT_INVALID_PARAM, e);
>     }
> }
> ```

在NacosConfigService的构造方法中，当这个类被实例化以后，有做一些事情 

- 初始化一个HttpAgent，这里又用到了装饰起模式，实际工作的类是ServerHttpAgent, MetricsHttpAgent内部也是调用了ServerHttpAgent的方法，增加了监控统计的信息 
- ClientWorker， 客户端的一个工作类，agent作为参数传入到clientworker，可以基本猜测到里面会用到agent做一些远程相关的事情

```java
public NacosConfigService(Properties properties) throws NacosException {
    String encodeTmp = properties.getProperty(PropertyKeyConst.ENCODE);
    if (StringUtils.isBlank(encodeTmp)) {
        encode = Constants.ENCODE;
    } else {
        encode = encodeTmp.trim();
    }
    initNamespace(properties); // 初始化配置文件的 命名空间
    // ServerHttpAgent 利用了MetricsHttpAgent做了一层包装，配置监控埋点
    agent = new MetricsHttpAgent(new ServerHttpAgent(properties));
    agent.start();
    worker = new ClientWorker(agent, configFilterChainManager, properties);
}
```

### ClientWorker

可以看到 ClientWorker 除了将 HttpAgent 维持在自己内部，还创建了两个线程池：

- 第一个线程池是只拥有一个线程用来执行定时任务的 executor，executor 每隔 10ms 就会执行一次 checkConfigInfo() 方法，从方法名上可以知道是每 10 ms 检查一次配置信息。 
- 第二个线程池是一个普通的线程池，从 ThreadFactory 的名称可以看到这个线程池是做长轮询的。

```java
public ClientWorker(final HttpAgent agent, final ConfigFilterChainManager configFilterChainManager, final Properties properties) {
    this.agent = agent;
    this.configFilterChainManager = configFilterChainManager;

    // Initialize the timeout parameter
	// 初始化超时参数，尝试读取配置文件中的超时配置，
    init(properties);
	// 初始化一个定时调度的线程池，重写了threadfactory方法
    executor = Executors.newScheduledThreadPool(1, new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName("com.alibaba.nacos.client.Worker." + agent.getName());
            t.setDaemon(true);
            return t;
        }
    });
	// 初始化一个定时调度的线程池，从里面的name名字来看，似乎和长轮训有关系。而这个长轮训应该是和nacos服务端的长轮训
    executorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors(), new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r);
            t.setName("com.alibaba.nacos.client.Worker.longPolling." + agent.getName());
            t.setDaemon(true);
            return t;
        }
    });
	// 设置定时任务的执行频率，并且调用checkConfigInfo这个方法，猜测是定时去检测配置是否发生了变化
	// 首次执行延迟时间为1毫秒、延迟时间为10毫秒
    executor.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            try {
                checkConfigInfo();
            } catch (Throwable e) {
                LOGGER.error("[" + agent.getName() + "] [sub-check] rotate check error", e);
            }
        }
    }, 1L, 10L, TimeUnit.MILLISECONDS);
}
```

### checkConfigInfo

接着，我们顺着初始化的代码，继续往下看. 

这个方法主要的目的是用来检查服务端的配置信息是否发生了变化。如果有变化，则触发listener通知 cacheMap: AtomicReference> cacheMap 用来存储监听变更的缓存集合。key是根据dataID/group/tenant(租户) 拼接的值。Value是对应存储在nacos服务器上的配置文件的内容。 

默认情况下，每个长轮训LongPullingRunnable任务默认处理3000个监听配置集。如果超过3000， 则 需要启动多个LongPollingRunnable去执行。 

`currentLongingTaskCount` 保存已启动的LongPullingRunnable任务数

```java
public void checkConfigInfo() {
    // 总的监听配置文件任务数
    int listenerSize = cacheMap.get().size();
    // 向上取整为批数, 监听的配置数量除以3000，得到一个整数，代表长轮训任务的数量
    int longingTaskCount = (int) Math.ceil(listenerSize / ParamUtil.getPerTaskConfigSize());
    // currentLongingTaskCount 表示当前的长轮训任务数量（长轮询线程数），如果小于计算的结果，则可以继续创建
    if (longingTaskCount > currentLongingTaskCount) {
        for (int i = (int) currentLongingTaskCount; i < longingTaskCount; i++) {
            // 要判断任务是否在执行 这块需要好好想想。 任务列表现在是无序的。变化过程可能有问题
            executorService.execute(new LongPollingRunnable(i));
        }
        currentLongingTaskCount = longingTaskCount; // 更新当前长轮训人数数量
    }
}
```

### LongPollingRunnable.run

初始化new LongPollingRunnable()丢给 executorService线程池来处理，所以我们可以找到 LongPollingRunnable里面的run方法 

这个方法传递了一个taskid， tasked用来区分cacheMap中的任务批次, 保存到cacheDatas这个集合中 `cacheData.isUseLocalConfigInfo` 这个值的变化来自于 checkLocalConfig 这个方法

> com.alibaba.nacos.client.config.impl.ClientWorker.LongPollingRunnable

```java
class LongPollingRunnable implements Runnable {
    private int taskId;

    public LongPollingRunnable(int taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        List<CacheData> cacheDatas = new ArrayList<CacheData>();
        List<String> inInitializingCacheList = new ArrayList<String>();
        try {
            // tasked用来区分cacheMap中的任务批次, 保存到cacheDatas这个集合中
            for (CacheData cacheData : cacheMap.get().values()) {
                if (cacheData.getTaskId() == taskId) {
                    cacheDatas.add(cacheData);
                    try {
                        // 通过本地文件中缓存的数据和cacheData集合中的数据进行比对，判断是否出现数据变化
                        checkLocalConfig(cacheData);
						
                        // 这里表示数据有变化，需要通知监听器
                        if (cacheData.isUseLocalConfigInfo()) {
                            cacheData.checkListenerMd5();
                        }
                    } catch (Exception e) {
                        LOGGER.error("get local config info error", e);
                    }
                }
            }

            // 代码省略...
    }
}
```

### checkLocalConfig

检查本地配置，这里面有三种情况 

- 第一种情况：如果isUseLocalConfigInfo为false，但是本地缓存路径的文件是存在的，那么把 isUseLocalConfigInfo设置为true，并且更新cacheData的内容以及文件的更新时间 
- 第二种情况：如果isUseLocalCOnfigInfo为true，但是本地缓存文件不存在，则设置为false，不通知监听器 
- 第三种情况：isUseLocalConfigInfo为true，并且本地缓存文件也存在，但是缓存的的时间和文件的更新时间不一致，则更新cacheData中的内容，并且isUseLocalConfigInfo设置为true

> com.alibaba.nacos.client.config.impl.ClientWorker#checkLocalConfig

```java
private void checkLocalConfig(CacheData cacheData) {
    final String dataId = cacheData.dataId;
    final String group = cacheData.group;
    final String tenant = cacheData.tenant;
    File path = LocalConfigInfoProcessor.getFailoverFile(agent.getName(), dataId, group, tenant);

    // 没有使用本地配置信息 && 本地配置文件存在
    if (!cacheData.isUseLocalConfigInfo() && path.exists()) {
        // 读取本地配置文件
        String content = LocalConfigInfoProcessor.getFailover(agent.getName(), dataId, group, tenant);
        // 
        String md5 = MD5.getInstance().getMD5String(content);
        cacheData.setUseLocalConfigInfo(true);
        cacheData.setLocalConfigInfoVersion(path.lastModified()); // 设置最后一次修改时间
        cacheData.setContent(content);

        LOGGER.warn("[{}] [failover-change] failover file created. dataId={}, group={}, tenant={}, md5={}, content={}", agent.getName(), 
                    dataId, 
                    group, 
                    tenant, 
                    md5, 
                    ContentUtils.truncateContent(content));
        return;
    }

    // 有 -> 没有。不通知业务监听器，从server拿到配置后通知。
    if (cacheData.isUseLocalConfigInfo() && !path.exists()) {
        cacheData.setUseLocalConfigInfo(false);
        
        LOGGER.warn("[{}] [failover-change] failover file deleted. dataId={}, group={}, tenant={}", 
                    agent.getName(),
                    dataId, 
                    group, 
                    tenant);
        return;
    }

    // 有变更
    if (cacheData.isUseLocalConfigInfo() && path.exists()
        && cacheData.getLocalConfigInfoVersion() != path.lastModified()) {
        String content = LocalConfigInfoProcessor.getFailover(agent.getName(), dataId, group, tenant);
        String md5 = MD5.getInstance().getMD5String(content);
        cacheData.setUseLocalConfigInfo(true);
        cacheData.setLocalConfigInfoVersion(path.lastModified());
        cacheData.setContent(content);
        
        LOGGER.warn("[{}] [failover-change] failover file changed. dataId={}, group={}, tenant={}, md5={}, content={}",
                    agent.getName(), 
                    dataId, 
                    group, 
                    tenant, 
                    md5, 
                    ContentUtils.truncateContent(content));
    }
}
```

### checkListenerMd5

遍历用户自己添加的监听器，如果发现数据的md5值不同，则发送通知

> com.alibaba.nacos.client.config.impl.CacheData#checkListenerMd5

```java
void checkListenerMd5() {
    for (ManagerListenerWrap wrap : listeners) {
        if (!md5.equals(wrap.lastCallMd5)) {
            safeNotifyListener(dataId, group, content, type, md5, wrap);
        }
    }
}
```

### 检查服务端配置

在LongPollingRunnable.run中，先通过本地配置的读取和检查来判断数据是否发生变化从而实现变化的通知 

接着，当前的线程还需要去远程服务器上获得最新的数据，检查哪些数据发生了变化

- 通过checkUpdateDataIds获取远程服务器上数据变更的dataid 
- 遍历这些变化的集合，然后调用getServerConfig从远程服务器获得对应的内容 
- 更新本地的cache，设置为服务器端返回的内容 
- 最后遍历cacheDatas，找到变化的数据进行通知

> com.alibaba.nacos.client.config.impl.ClientWorker.LongPollingRunnable#run

```java
class LongPollingRunnable implements Runnable {
    private int taskId;

    public LongPollingRunnable(int taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {

        List<CacheData> cacheDatas = new ArrayList<CacheData>();
        List<String> inInitializingCacheList = new ArrayList<String>();
        try {
            // check failover config
            for (CacheData cacheData : cacheMap.get().values()) {
                if (cacheData.getTaskId() == taskId) {
                    cacheDatas.add(cacheData);
                    try {
                        checkLocalConfig(cacheData);
                        if (cacheData.isUseLocalConfigInfo()) {
                            cacheData.checkListenerMd5();
                        }
                    } catch (Exception e) {
                        LOGGER.error("get local config info error", e);
                    }
                }
            }

            // check server config
            // 从服务端获取发生变化的数据的DataID列表，保存在List<String>集合中
            List<String> changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);
            LOGGER.info("get changedGroupKeys:" + changedGroupKeys);
			
            // 在nacos服务器比对完配置文件后，返回不匹配的文件 id
            for (String groupKey : changedGroupKeys) {
                String[] key = GroupKey.parseKey(groupKey);
                String dataId = key[0];
                String group = key[1];
                String tenant = null;
                if (key.length == 3) {
                    tenant = key[2];
                }
                try {
                    // 遍历有变换的groupkey，发起远程请求获得指定groupkey的内容
                    String[] ct = getServerConfig(dataId, group, tenant, 3000L);
                    // 把获取到的内容设置到CacheData中
                    CacheData cache = cacheMap.get().get(GroupKey.getKeyTenant(dataId, group, tenant));
                    cache.setContent(ct[0]);
                    if (null != ct[1]) {
                        cache.setType(ct[1]);
                    }
                    
                    LOGGER.info("[{}] [data-received] dataId={}, group={}, tenant={}, md5={}, content={}, type={}", 
                                agent.getName(), 
                                dataId, 
                                group, 
                                tenant, 
                                cache.getMd5(),
                                ContentUtils.truncateContent(ct[0]), 
                                ct[1]);
                    
                } catch (NacosException ioe) {
                    String message = String.format("[%s] [get-update] get changed config exception. dataId=%s, group=%s, tenant=%s",
                                                   agent.getName(), 
                                                   dataId, 
                                                   group, 
                                                   tenant);
                    
                    LOGGER.error(message, ioe);
                }
            }
            // 再遍历CacheData这个集合，找到发生变化的数据进行通知
            for (CacheData cacheData : cacheDatas) {
                if (!cacheData.isInitializing() || inInitializingCacheList.contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) {
                    cacheData.checkListenerMd5();
                    cacheData.setInitializing(false);
                }
            }
            inInitializingCacheList.clear();

            executorService.execute(this); // 继续传递当前线程进行轮询

        } catch (Throwable e) {

            // If the rotation training task is abnormal, the next execution time of the task will be punished
            LOGGER.error("longPolling error : ", e);
            executorService.schedule(this, taskPenaltyTime, TimeUnit.MILLISECONDS);
        }
    }
}
```

### checkUpdateDataIds

- 首先从cacheDatas集合中找到isUseLocalConfigInfo为false的缓存 
- 调用checkUpdateConfigStr

> com.alibaba.nacos.client.config.impl.ClientWorker#checkUpdateDataIds

```java
/**
* 从Server获取值变化了的DataID列表。返回的对象里只有dataId和group是有效的。 保证不返回NULL。
*/
List<String> checkUpdateDataIds(List<CacheData> cacheDatas, List<String> inInitializingCacheList) throws IOException {
    StringBuilder sb = new StringBuilder();
    for (CacheData cacheData : cacheDatas) {
        if (!cacheData.isUseLocalConfigInfo()) {// 不使用本地配置信息
            sb.append(cacheData.dataId).append(WORD_SEPARATOR);
            sb.append(cacheData.group).append(WORD_SEPARATOR);
            if (StringUtils.isBlank(cacheData.tenant)) {
                sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);
            } else {
                sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);
                sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);
            }
            if (cacheData.isInitializing()) {
                // cacheData 首次出现在cacheMap中&首次check更新
                inInitializingCacheList
                    .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));
            }
        }
    }
    boolean isInitializingCacheList = !inInitializingCacheList.isEmpty();
    // 从Server获取值变化了的DataID列表。返回的对象里只有dataId和group是有效的。保证不返回NULL
    return checkUpdateConfigStr(sb.toString(), isInitializingCacheList);
}
```

通过长轮训的方式，从远程服务器获得变化的数据进行返回

> com.alibaba.nacos.client.config.impl.ClientWorker#checkUpdateConfigStr

```java
/**
* 从Server获取值变化了的DataID列表。返回的对象里只有dataId和group是有效的。保证不返回NULL。
* @param probeUpdateString 数据更变的dataId 相关的参数
*/
List<String> checkUpdateConfigStr(String probeUpdateString, boolean isInitializingCacheList) throws IOException {


    List<String> params = new ArrayList<String>(2);
    params.add(Constants.PROBE_MODIFY_REQUEST);
    params.add(probeUpdateString);

    List<String> headers = new ArrayList<String>(2);
    headers.add("Long-Pulling-Timeout");
    headers.add("" + timeout);

    // told server do not hang me up if new initializing cacheData added in
    if (isInitializingCacheList) {
        headers.add("Long-Pulling-Timeout-No-Hangup");
        headers.add("true");
    }

    if (StringUtils.isBlank(probeUpdateString)) {
        return Collections.emptyList();
    }

    try {
        // In order to prevent the server from handling the delay of the client's long task,
        // increase the client's read timeout to avoid this problem.

        long readTimeoutMs = timeout + (long) Math.round(timeout >> 1);
        HttpResult result = agent.httpPost(Constants.CONFIG_CONTROLLER_PATH + "/listener", 
                                           headers, 
                                           params,
                                           agent.getEncode(), 
                                           readTimeoutMs);

        if (HttpURLConnection.HTTP_OK == result.code) {
            setHealthServer(true);
            return parseUpdateDataIdResponse(result.content);
        } else {
            setHealthServer(false);
            LOGGER.error("[{}] [check-update] get changed dataId error, code: {}", 
                         agent.getName(), 
                         result.code);
        }
    } catch (IOException e) {
        setHealthServer(false);
        LOGGER.error("[" + agent.getName() + "] [check-update] get changed dataId exception", e);
        throw e;
    }
    return Collections.emptyList();
}
```

### getServerConfig

根据dataId、group、tenant等信息，使用http请求从远程服务器上获得配置信息，读取到数据之后缓 存到本地文件中

```java
// 根据nacos服务器返回的不匹配文件id，发起远程请求获得指定文件id的内容
public String[] getServerConfig(String dataId, String group, String tenant, long readTimeout)
        throws NacosException {
    String[] ct = new String[2];
    if (StringUtils.isBlank(group)) {
        group = Constants.DEFAULT_GROUP;
    }

    HttpResult result = null;
    try {
        List<String> params = null;
        if (StringUtils.isBlank(tenant)) {
            params = new ArrayList<String>(Arrays.asList("dataId", dataId, "group", group));
        } else {
            params = new ArrayList<String>(Arrays.asList("dataId", dataId, "group", group, "tenant", tenant));
        }
        result = agent.httpGet(Constants.CONFIG_CONTROLLER_PATH, null, params, agent.getEncode(), readTimeout);
    } catch (IOException e) {
        String message = String.format(
            "[%s] [sub-server] get server config exception, dataId=%s, group=%s, tenant=%s", agent.getName(),
            dataId, group, tenant);
        LOGGER.error(message, e);
        throw new NacosException(NacosException.SERVER_ERROR, e);
    }

    switch (result.code) {
        case HttpURLConnection.HTTP_OK:
            // 存储快照
            LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, result.content);
            ct[0] = result.content;
            if (result.headers.containsKey(CONFIG_TYPE)) {
                ct[1] = result.headers.get(CONFIG_TYPE).get(0);
            } else {
                ct[1] = ConfigType.TEXT.getType();
            }
            return ct;
        case HttpURLConnection.HTTP_NOT_FOUND:
            LocalConfigInfoProcessor.saveSnapshot(agent.getName(), dataId, group, tenant, null);
            return ct;
        case HttpURLConnection.HTTP_CONFLICT: {
            
            LOGGER.error("[{}] [sub-server-error] get server config being modified concurrently, dataId={}, group={}, " + "tenant={}", 
                         agent.getName(), 
                         dataId, 
                         group, 
                         tenant);
            
            throw new NacosException(NacosException.CONFLICT, "data being modified, dataId=" + dataId + ",group=" + group + ",tenant=" + tenant);
        }
        case HttpURLConnection.HTTP_FORBIDDEN: {
            LOGGER.error("[{}] [sub-server-error] no right, dataId={}, group={}, tenant={}",
                         agent.getName(), 
                         dataId,
                         group, 
                         tenant);
            
            throw new NacosException(result.code, result.content);
        }
        default: {
            LOGGER.error("[{}] [sub-server-error]  dataId={}, group={}, tenant={}, code={}", 
                         agent.getName(), 
                         dataId,
                         group, 
                         tenant, 
                         result.code);
            
            throw new NacosException(result.code, "http error, code=" + result.code + ",dataId=" + dataId + ",group=" + group + ",tenant=" + tenant);
        }
    }
}
```





### com.alibaba.nacos.config.server.controller.ConfigController

nacos是使用spring mvc提供的rest api。这里面会调用inner.doPollingConfig进行处理

```java
@RestController
@RequestMapping(Constants.CONFIG_CONTROLLER_PATH)
public class ConfigController {
    // 客户端配置长轮询请求处理
    @PostMapping("/listener")
    @Secured(action = ActionTypes.READ, parser = ConfigResourceParser.class)
    public void listener(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setAttribute("org.apache.catalina.ASYNC_SUPPORTED", true);
        String probeModify = request.getParameter("Listening-Configs");
        if (StringUtils.isBlank(probeModify)) {
            throw new IllegalArgumentException("invalid probeModify");
        }
        
        probeModify = URLDecoder.decode(probeModify, Constants.ENCODE);
        
        Map<String, String> clientMd5Map;
        try {
            clientMd5Map = MD5Util.getClientMd5Map(probeModify);
        } catch (Throwable e) {
            throw new IllegalArgumentException("invalid probeModify");
        }
        
        // 处理长轮询请求
        inner.doPollingConfig(request, response, clientMd5Map, probeModify.length());
    }
    
}
```

### inner.doPollingConfig

这个方法中，兼容了长轮训和短轮询的逻辑，我们只需要关注长轮训的部分。再次进入到 `longPollingService.addLongPollingClient`

> com.alibaba.nacos.config.server.controller.ConfigServletInner#doPollingConfig

```java
/**
* 处理长轮询接口
*/
public String doPollingConfig(HttpServletRequest request, HttpServletResponse response,
                              Map<String, String> clientMd5Map, int probeRequestSize) throws IOException {

    // 长轮询
    if (LongPollingService.isSupportLongPolling(request)) {
        longPollingService.addLongPollingClient(request, response, clientMd5Map, probeRequestSize);
        return HttpServletResponse.SC_OK + "";
    }
	// 下面逻辑 兼容短轮询逻辑
    // Compatible with short polling logic.
    List<String> changedGroups = MD5Util.compareMd5(request, response, clientMd5Map);

    // Compatible with short polling result.
    String oldResult = MD5Util.compareMd5OldResult(changedGroups);
    String newResult = MD5Util.compareMd5ResultString(changedGroups);

    String version = request.getHeader(Constants.CLIENT_VERSION_HEADER);
    if (version == null) {
        version = "2.0.0";
    }
    int versionNum = Protocol.getVersionNumber(version);

    // Befor 2.0.4 version, return value is put into header.
    if (versionNum < START_LONG_POLLING_VERSION_NUM) {
        response.addHeader(Constants.PROBE_MODIFY_RESPONSE, oldResult);
        response.addHeader(Constants.PROBE_MODIFY_RESPONSE_NEW, newResult);
    } else {
        request.setAttribute("content", newResult);
    }

    Loggers.AUTH.info("new content:" + newResult);

    // Disable cache.
    // 禁用缓存
    response.setHeader("Pragma", "no-cache");
    response.setDateHeader("Expires", 0);
    response.setHeader("Cache-Control", "no-cache,no-store");
    response.setStatus(HttpServletResponse.SC_OK);
    return HttpServletResponse.SC_OK + "";
}
```

### longPollingService.addLongPollingClient

从方法名字上可以推测出，这个方法应该是把客户端的长轮训请求添加到某个任务中去。 

- 获得客户端传递过来的超时时间，并且进行本地计算，提前500ms返回响应，这就能解释为什么客户端响应超时时间是29.5+了。当然如果 isFixedPolling=true 的情况下，不会提前返回响应 
- 根据客户端请求过来的md5和服务器端对应的group下对应内容的md5进行比较，如果不一致，则通过 generateResponse 将结果返回 
- 如果配置文件没有发生变化，则通过 scheduler.execute 启动了一个定时任务，将客户端的长轮 询请求封装成一个叫 ClientLongPolling 的任务，交给 scheduler 去执行

```java
public void addLongPollingClient(
    HttpServletRequest req, 
    HttpServletResponse rsp, 
    Map<String, String> clientMd5Map,
    int probeRequestSize) {

    // str表示超时时间，也就是timeout
    String str = req.getHeader(LongPollingService.LONG_POLLING_HEADER);
    String noHangUpFlag = req.getHeader(LongPollingService.LONG_POLLING_NO_HANG_UP_HEADER);
    String appName = req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);
    String tag = req.getHeader("Vipserver-Tag");
    int delayTime = SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, 500);

    // Add delay time for LoadBalance, and one response is returned 500 ms in advance to avoid client timeout.
    // 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动
    long timeout = Math.max(10000, Long.parseLong(str) - delayTime);
    if (isFixedPolling()) {
        timeout = Math.max(10000, getFixedPollingInterval());
        // Do nothing but set fix polling timeout.
    } else {
        long start = System.currentTimeMillis();
        // 根据客户端请求过来的md5和服务器端对应的group下对应内容的md5进行比较，如果不一致，则通过`generateResponse`将结果返回
        List<String> changedGroups = MD5Util.compareMd5(req, rsp, clientMd5Map);
        if (changedGroups.size() > 0) {
            generateResponse(req, rsp, changedGroups);
            LogUtil.CLIENT_LOG.info("{}|{}|{}|{}|{}|{}|{}", 
                                    System.currentTimeMillis() - start, 
                                    "instant",
                                    RequestUtil.getRemoteIp(req), 
                                    "polling", 
                                    clientMd5Map.size(), 
                                    probeRequestSize,
                                    changedGroups.size());
            return;
        } else if (noHangUpFlag != null && noHangUpFlag.equalsIgnoreCase(TRUE_STR)) {
            LogUtil.CLIENT_LOG.info("{}|{}|{}|{}|{}|{}|{}", 
                                    System.currentTimeMillis() - start, 
                                    "nohangup",
                                    RequestUtil.getRemoteIp(req), 
                                    "polling", clientMd5Map.size(), 
                                    probeRequestSize,
                                    changedGroups.size());
            return;
        }
    }
    String ip = RequestUtil.getRemoteIp(req);

    // Must be called by http thread, or send response.
    // 一定要由HTTP线程调用，否则离开后容器会立即发送响应
    final AsyncContext asyncContext = req.startAsync();
    // AsyncContext是Servlet3.0中提供的对象，调用startAsync获得AsyncContext对象之后，这个请求的响应会被延后，并释放容器分配的线程。
	// 这样就可以实现长轮询的机制.

    // AsyncContext.setTimeout() is incorrect, Control by oneself
    // AsyncContext.setTimeout()的超时时间不准，所以只能自己控制
    asyncContext.setTimeout(0L);

    ConfigExecutor.executeLongPolling(new ClientLongPolling(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));
}
```

### ClientLongPolling

接下来我们来分析一下，clientLongPolling到底做了什么操作。或者说我们可以先猜测一下应该会做什么事情 

- 这个任务要阻塞29.5s才能执行，因为立马执行没有任何意义，毕竟前面已经执行过一次了 
- 如果在29.5s+之内，数据发生变化，需要提前通知。需要有一种监控机制 

基于这些猜想，我们可以看看它的实现过程 

从代码粗粒度来看，它的实现似乎和我们的猜想一致，在run方法中，通过scheduler.schedule实现了 一个定时任务，它的delay时间正好是前面计算的29.5s。在这个任务中，会通过MD5Util.compareMd5 来进行计算 

那另外一个，当数据发生变化以后，肯定不能等到29.5s之后才通知呀，那怎么办呢？我们发现有一个 allSubs 的东西，它似乎和发布订阅有关系。那是不是有可能当前的clientLongPolling订阅了数据变化的事件呢？

```java
class ClientLongPolling implements Runnable {
        
    @Override
    public void run() {
        // 这里进行延时处理
        asyncTimeoutFuture = ConfigExecutor.scheduleLongPolling(new Runnable() {
            @Override
            public void run() {
                try {
                    getRetainIps().put(ClientLongPolling.this.ip, System.currentTimeMillis());

                    // Delete subsciber's relations.
                    allSubs.remove(ClientLongPolling.this);

                    if (isFixedPolling()) {
                        LogUtil.CLIENT_LOG.info("{}|{}|{}|{}|{}|{}",
                                                (System.currentTimeMillis() - createTime),
                                                "fix",
                                                RequestUtil.getRemoteIp((HttpServletRequest) asyncContext.getRequest()),
                                                "polling", 
                                                clientMd5Map.size(), 
                                                probeRequestSize);
                        // 先进行文件判断，如果有存在不匹配的文件，则立即返回
                        List<String> changedGroups = MD5Util.compareMd5(
                            (HttpServletRequest) asyncContext.getRequest(),
                            (HttpServletResponse) asyncContext.getResponse(), clientMd5Map);
                        
                        if (changedGroups.size() > 0) {
                            sendResponse(changedGroups);
                        } else {
                            sendResponse(null);
                        }
                    } else {
                        LogUtil.CLIENT_LOG.info("{}|{}|{}|{}|{}|{}", 
                                  (System.currentTimeMillis() - createTime), 
                                  "timeout",
                                  RequestUtil.getRemoteIp((HttpServletRequest) asyncContext.getRequest()),
                                  "polling", 
                                  clientMd5Map.size(), 
                                  probeRequestSize);
                        
                        sendResponse(null);
                    }
                } catch (Throwable t) {
                    LogUtil.DEFAULT_LOG.error("long polling error:" + t.getMessage(), t.getCause());
                }

            }

        }, timeoutTime, TimeUnit.MILLISECONDS);

        allSubs.add(this);
    }

    void sendResponse(List<String> changedGroups) {

        // Cancel time out task.
        if (null != asyncTimeoutFuture) {
            asyncTimeoutFuture.cancel(false);
        }
        generateResponse(changedGroups);
    }

    void generateResponse(List<String> changedGroups) {
        if (null == changedGroups) {

            // Tell web container to send http response.
            asyncContext.complete();
            return;
        }

        HttpServletResponse response = (HttpServletResponse) asyncContext.getResponse();

        try {
            final String respString = MD5Util.compareMd5ResultString(changedGroups);

            // Disable cache.
            response.setHeader("Pragma", "no-cache");
            response.setDateHeader("Expires", 0);
            response.setHeader("Cache-Control", "no-cache,no-store");
            response.setStatus(HttpServletResponse.SC_OK);
            response.getWriter().println(respString);
            asyncContext.complete();
        } catch (Exception ex) {
            PULL_LOG.error(ex.toString(), ex);
            asyncContext.complete();
        }
    }

    ClientLongPolling(AsyncContext ac, Map<String, String> clientMd5Map, String ip, int probeRequestSize, long timeoutTime, String appName, String tag) {
        this.asyncContext = ac;
        this.clientMd5Map = clientMd5Map;
        this.probeRequestSize = probeRequestSize;
        this.createTime = System.currentTimeMillis();
        this.ip = ip;
        this.timeoutTime = timeoutTime;
        this.appName = appName;
        this.tag = tag;
    }

    final AsyncContext asyncContext;

    final Map<String, String> clientMd5Map;

    final long createTime;

    final String ip;

    final String appName;

    final String tag;

    final int probeRequestSize;

    final long timeoutTime;

    Future<?> asyncTimeoutFuture;

    @Override
    public String toString() {
        return "ClientLongPolling{" + "clientMd5Map=" + clientMd5Map + ", createTime=" + createTime + ", ip='" + ip + '\'' + ", appName='" + appName + '\'' + ", tag='" + tag + '\'' + ", probeRequestSize=" + probeRequestSize + ", timeoutTime=" + timeoutTime + '}';
    }
}
```

### allSubs

allSubs是一个队列，队列里面放了ClientLongPolling这个对象。这个队列似乎和配置变更有某种关联 关系。

那么这里必须要实现的是，当用户在nacos 控制台修改了配置之后，必须要从这个订阅关系中取出关注 的客户端长连接，然后把变更的结果返回。于是我们去看LongPollingService的构造方法查找订阅关系

```java
/**
* 长轮询订阅关系
*/
final Queue<ClientLongPolling> allSubs;

allSubs.add(this);
```

### LongPollingService

在LongPollingService的构造方法中，使用了一个NotifyCenter订阅了一个事件，其中不难发现，如果 这个事件的实例是LocalDataChangeEvent，也就是服务端数据发生变更的时间，就会执行一个 DataChangeTask 的线程。

> com.alibaba.nacos.config.server.service.LongPollingService#LongPollingService

```java
// 构造方法
public LongPollingService() {
    allSubs = new ConcurrentLinkedQueue<ClientLongPolling>();

    ConfigExecutor.scheduleLongPolling(new StatTask(), 0L, 10L, TimeUnit.SECONDS);

    // Register LocalDataChangeEvent to NotifyCenter.
    NotifyCenter.registerToPublisher(LocalDataChangeEvent.class, NotifyCenter.ringBufferSize);

    // Register A Subscriber to subscribe LocalDataChangeEvent.
    NotifyCenter.registerSubscriber(new Subscriber() {

        @Override
        public void onEvent(Event event) {
            if (isFixedPolling()) {
                // Ignore.
            } else {
                if (event instanceof LocalDataChangeEvent) {
                    LocalDataChangeEvent evt = (LocalDataChangeEvent) event;
                    ConfigExecutor.executeLongPolling(new DataChangeTask(evt.groupKey, evt.isBeta, evt.betaIps));
                }
            }
        }

        @Override
        public Class<? extends Event> subscribeType() {
            return LocalDataChangeEvent.class;
        }
    });

}
```

### DataChangeTask.run

从名字可以看出来，这个是数据变化的任务，最让人兴奋的应该是，它里面有一个循环迭代器，从 allSubs里面获得ClientLongPolling

最后通过clientSub.sendResponse把数据返回到客户端。所以，这也就能够理解为何数据变化能够实 时触发更新了。

```java
class DataChangeTask implements Runnable {
        
    @Override
    public void run() {
        try {
            ConfigCacheService.getContentBetaMd5(groupKey);
            for (Iterator<ClientLongPolling> iter = allSubs.iterator(); iter.hasNext(); ) {
                ClientLongPolling clientSub = iter.next();
                // 判断当前的连接是否监听这个文件的变更处理。
                if (clientSub.clientMd5Map.containsKey(groupKey)) { 
                    
                    // If published tag is not in the beta list, then it skipped.
                    if (isBeta && !CollectionUtils.contains(betaIps, clientSub.ip)) {
                        continue;
                    }

                    // If published tag is not in the tag list, then it skipped.
                    if (StringUtils.isNotBlank(tag) && !tag.equals(clientSub.tag)) {
                        continue;
                    }

                    getRetainIps().put(clientSub.ip, System.currentTimeMillis());
                    iter.remove(); // Delete subscribers' relationships.
                    
                    LogUtil.CLIENT_LOG.info("{}|{}|{}|{}|{}|{}|{}", 
                                            (System.currentTimeMillis() - changeTime), 
                                            "in-advance",
                                            RequestUtil.getRemoteIp((HttpServletRequest) clientSub.asyncContext.getRequest()),
                                            "polling", 
                                            clientSub.clientMd5Map.size(),
                                            clientSub.probeRequestSize, 
                                            groupKey);
                    
                    clientSub.sendResponse(Arrays.asList(groupKey));
                }
            }
        } catch (Throwable t) {
            LogUtil.DEFAULT_LOG.error("data change error: {}", ExceptionUtil.getStackTrace(t));
        }
    }

    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps) {
        this(groupKey, isBeta, betaIps, null);
    }

    DataChangeTask(String groupKey, boolean isBeta, List<String> betaIps, String tag) {
        this.groupKey = groupKey;
        this.isBeta = isBeta;
        this.betaIps = betaIps;
        this.tag = tag;
    }

    final String groupKey;

    final long changeTime = System.currentTimeMillis();

    final boolean isBeta;

    final List<String> betaIps;

    final String tag;
}
```

