# Nacos服务注册的原理

## Nacos API

详情请参考 [Nacos Api](https://nacos.io/zh-cn/docs/open-api.html)

**服务发现**

| 请求路径                   | 请求类型 | 描述                         |
| -------------------------- | -------- | ---------------------------- |
| /nacos/v1/ns/instance      | POST     | 注册一个实例到服务           |
| /nacos/v1/ns/instance      | DELETE   | 删除服务下的一个实例         |
| /nacos/v1/ns/instance      | PUT      | 修改实例                     |
| /nacos/v1/ns/instance/list | GET      | 查询实例列表                 |
| /nacos/v1/ns/instance      | GET      | 查询一个服务下个某个实例详情 |
| ...                        |          |                              |



**配置管理**

| 请求路径                      | 请求类型 | 描述                                                         |
| ----------------------------- | -------- | ------------------------------------------------------------ |
| /nacos/v1/cs/configs          | GET      | 获取Nacos上的配置。                                          |
| /nacos/v1/cs/configs/listener | POST     | 监听 Nacos 上的配置，以便实时感知配置变更。如果配置变更，则用[获取配置](https://nacos.io/zh-cn/docs/~~64131~~)接口获取配置的最新值，动态刷新本地缓存。<br /><br />注册监听采用的是异步 Servlet 技术。注册监听本质就是带着配置和配置值的 MD5 值和后台对比。如果 MD5 值不一致，就立即返回不一致的配置。如果值一致，就等待住 30 秒。返回值为空。 |
| /nacos/v1/cs/configs          | POST     | 发布 Nacos 上的配置                                          |
| /nacos/v1/cs/configs          | DELETE   | 删除 Nacos 上的配置                                          |



## Nacos实现原理

**心跳机制**

- 心跳的发送间隔 
- 心跳的超时时间 
  - 设置一个心跳超时的阈值 
  - 记录针对于某一个服务实例的最后一次更新的时间 
  - 计算公式：当前时间 - 当前实例最后一次更新的时间 > 心跳超时的阈值

**nacos原理图**

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/nacos/20201123140302.jpg)

# Nacos的源码分析

## 服务注册的流程

Dubbo服务注册的流程有两个，一个是和之前分析Eureka源码时的路径一样（参考Eureka源码分析） 另一个是基于Dubbo本身提供的自动装配机制，而在基于Dubbo服务发布的过程中， 是走的事件监听机制，在 DubboServiceRegistrationNonWebApplicationAutoConfiguration 这个类中，这个类会 监听 ApplicationStartedEvent 事件，这个时间是spring boot在2.0新增的，就是当spring boot应用 启动完成之后会发布这个时间。而此时监听到这个事件之后，会触发注册的动作。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnNotWebApplication
@ConditionalOnProperty(value = "spring.cloud.service-registry.auto-registration.enabled",
		matchIfMissing = true)
@AutoConfigureAfter(DubboServiceRegistrationAutoConfiguration.class)
@Aspect
public class DubboServiceRegistrationNonWebApplicationAutoConfiguration {
    @EventListener(ApplicationStartedEvent.class)
	public void onApplicationStarted() {
		setServerPort();
		register();
	}
    
    private void register() {
		if (registered) {
			return;
		}
        // this.serviceRegistry 是一个注入的实例： NacosServiceRegistry
		serviceRegistry.register(registration); 
		registered = true;
	}
}
```

### 一. 客户端发送请求

### NacosServiceRegistry.register

serviceId ， 对应当前应用的application.name 

group，表示nacos上的分组配置 

instance，表示服务实例信息

```java
@Override
public void register(Registration registration) {

    if (StringUtils.isEmpty(registration.getServiceId())) {
        log.warn("No service to register for nacos client...");
        return;
    }
	// 获取服务id
    String serviceId = registration.getServiceId();
    // 获取分组名称
    String group = nacosDiscoveryProperties.getGroup();

    Instance instance = getNacosInstanceFromRegistration(registration);

    try {
        // 执行注册操作
        namingService.registerInstance(serviceId, group, instance);
        log.info("nacos registry, {} {} {}:{} register finished", group, serviceId,
                 instance.getIp(), instance.getPort());
    }
    catch (Exception e) {
        log.error("nacos registry, {} register failed...{},", serviceId,
                  registration.toString(), e);
        // rethrow a RuntimeException if the registration is failed.
        // issue : https://github.com/alibaba/spring-cloud-alibaba/issues/1132
        rethrowRuntimeException(e);
    }
}
```

### NacosNamingService.registerInstance

开始注册实例，主要做两个动作

- 如果当前注册的是临时节点，则构建心跳信息，通过beat反应堆来构建心跳任务
- 调用registerService发起服务注册

```java
@Override
public void registerInstance(String serviceName, String groupName, Instance instance) throws NacosException {
	
    if (instance.isEphemeral()) {
        // 是否是临时节点，如果是临时节点，则构建心跳信息
        BeatInfo beatInfo = new BeatInfo();
        beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));
        beatInfo.setIp(instance.getIp());
        beatInfo.setPort(instance.getPort());
        beatInfo.setCluster(instance.getClusterName());
        beatInfo.setWeight(instance.getWeight());
        beatInfo.setMetadata(instance.getMetadata());
        beatInfo.setScheduled(false);
        beatInfo.setPeriod(instance.getInstanceHeartBeatInterval()); // 心跳时间，默认5s
		// beatReactor， 添加心跳信息进行处理
        beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);
    }

    serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);
}



public class BeatReactor {
    // 创建心跳定时器
	public void addBeatInfo(String serviceName, BeatInfo beatInfo) {
        NAMING_LOGGER.info("[BEAT] adding beat: {} to beat map.", beatInfo);
        String key = buildKey(serviceName, beatInfo.getIp(), beatInfo.getPort());
        BeatInfo existBeat = null;
        //fix #1733
        if ((existBeat = dom2Beat.remove(key)) != null) {
            existBeat.setStopped(true);
        }
        dom2Beat.put(key, beatInfo);
        executorService.schedule(new BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);
        MetricsMonitor.getDom2BeatSizeMonitor().set(dom2Beat.size());
    }
}
```

### NamingProxy.registerService

- 代码逻辑很简单，构建请求参数 
- 发起请求

```java
public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {

    NAMING_LOGGER.info("[REGISTER-SERVICE] {} registering service {} with instance: {}", namespaceId, serviceName, instance);
	
    // 构建实例信息
    final Map<String, String> params = new HashMap<String, String>(9);
    params.put(CommonParams.NAMESPACE_ID, namespaceId); // 命名空间
    params.put(CommonParams.SERVICE_NAME, serviceName); // 实例名称
    params.put(CommonParams.GROUP_NAME, groupName); // 分组名称
    params.put(CommonParams.CLUSTER_NAME, instance.getClusterName()); // 集群名称
    params.put("ip", instance.getIp());
    params.put("port", String.valueOf(instance.getPort()));
    params.put("weight", String.valueOf(instance.getWeight()));
    params.put("enable", String.valueOf(instance.isEnabled()));
    params.put("healthy", String.valueOf(instance.isHealthy()));
    params.put("ephemeral", String.valueOf(instance.isEphemeral()));
    params.put("metadata", JSON.toJSONString(instance.getMetadata()));
	
    reqAPI(UtilAndComs.NACOS_URL_INSTANCE, params, HttpMethod.POST); // 调用注册API
}
```

### reqAPI

发起服务注册请求。

- api: nacos server open api 
- params: 请求参数 
- body： 
- method： 请求方法类型 
- servers: nacos server地址

```java
public String reqAPI(String api, Map<String, String> params, String body, List<String> servers, String method) throws NacosException {

    params.put(CommonParams.NAMESPACE_ID, getNamespaceId());

    if (CollectionUtils.isEmpty(servers) && StringUtils.isEmpty(nacosDomain)) {
        throw new NacosException(NacosException.INVALID_PARAM, "no server available");
    }

    NacosException exception = new NacosException();
	//如果nacos服务地址不为空
    if (servers != null && !servers.isEmpty()) {
		//随机获取一台nacos服务节点
        Random random = new Random(System.currentTimeMillis());
        int index = random.nextInt(servers.size());
		// 遍历服务列表
        for (int i = 0; i < servers.size(); i++) {
             //获得索引位置的服务节点
            String server = servers.get(index);
            try {
                //调用指定服务
                return callServer(api, params, body, server, method);
            } catch (NacosException e) {
                exception = e;
                if (NAMING_LOGGER.isDebugEnabled()) {
                    NAMING_LOGGER.debug("request {} failed.", server, e);
                }
            }
            // 轮询
            index = (index + 1) % servers.size();
        }
    }

    if (StringUtils.isNotBlank(nacosDomain)) {
        for (int i = 0; i < UtilAndComs.REQUEST_DOMAIN_RETRY_COUNT; i++) {
            try {
                return callServer(api, params, body, nacosDomain, method);
            } catch (NacosException e) {
                exception = e;
                if (NAMING_LOGGER.isDebugEnabled()) {
                    NAMING_LOGGER.debug("request {} failed.", nacosDomain, e);
                }
            }
        }
    }

    NAMING_LOGGER.error("request: {} failed, servers: {}, code: {}, msg: {}", api, servers, exception.getErrCode(), exception.getErrMsg());

    throw new NacosException(exception.getErrCode(), "failed to req API:/api/" + api + " after all servers(" + servers + ") tried: " + exception.getMessage());

}
```

### callServer

发起服务调用

> com.alibaba.nacos.client.naming.net.NamingProxy#callServer

```java
public String callServer(String api, Map<String, String> params, String body, String curServer, String method) throws NacosException {
    long start = System.currentTimeMillis();
    long end = 0;
    // 添加签名信息 往params添加"app","signature","data","ak"参数
    injectSecurityInfo(params);
    // 添加头信息
    List<String> headers = builderHeaders();

    String url; // 拼接url地址
    if (curServer.startsWith(UtilAndComs.HTTPS) || curServer.startsWith(UtilAndComs.HTTP)) {
        url = curServer + api;
    } else {
        if (!curServer.contains(UtilAndComs.SERVER_ADDR_IP_SPLITER)) {
            curServer = curServer + UtilAndComs.SERVER_ADDR_IP_SPLITER + serverPort;
        }
        url = HttpClient.getPrefix() + curServer + api;
    }
	// 通过httpclient发起请求
    HttpClient.HttpResult result = HttpClient.request(url, headers, params, body, UtilAndComs.ENCODING, method);
    end = System.currentTimeMillis();
	// 监控埋点 向监控发送请求时间
    MetricsMonitor.getNamingRequestMonitor(method, url, String.valueOf(result.code)).observe(end - start);

    if (HttpURLConnection.HTTP_OK == result.code) {// 返回服务端的结果
        return result.content;
    }

    if (HttpURLConnection.HTTP_NOT_MODIFIED == result.code) {
        return StringUtils.EMPTY;
    }

    throw new NacosException(result.code, result.content);
}

// nacos http请求是用原生jdk HttpURLConnection 方式
public class HttpClient {
    public static HttpResult request(String url, List<String> headers, Map<String, String> paramValues, String body, String encoding, String method) {
        HttpURLConnection conn = null;
        try {
            String encodedContent = encodingParams(paramValues, encoding);
            url += (StringUtils.isEmpty(encodedContent)) ? "" : ("?" + encodedContent);

            conn = (HttpURLConnection) new URL(url).openConnection();

            setHeaders(conn, headers, encoding);
            conn.setConnectTimeout(CON_TIME_OUT_MILLIS);
            conn.setReadTimeout(TIME_OUT_MILLIS);
            conn.setRequestMethod(method);
            conn.setDoOutput(true);
            if (StringUtils.isNotBlank(body)) {
                byte[] b = body.getBytes();
                conn.setRequestProperty("Content-Length", String.valueOf(b.length));
                conn.getOutputStream().write(b, 0, b.length);
                conn.getOutputStream().flush();
                conn.getOutputStream().close();
            }
            conn.connect();
            if (NAMING_LOGGER.isDebugEnabled()) {
                NAMING_LOGGER.debug("Request from server: " + url);
            }
            return getResult(conn);
        } catch (Exception e) {
            try {
                if (conn != null) {
                    NAMING_LOGGER.warn("failed to request " + conn.getURL() + " from "
                        + InetAddress.getByName(conn.getURL().getHost()).getHostAddress());
                }
            } catch (Exception e1) {
                NAMING_LOGGER.error("[NA] failed to request ", e1);
                //ignore
            }

            NAMING_LOGGER.error("[NA] failed to request ", e);

            return new HttpResult(500, e.toString(), Collections.<String, String>emptyMap());
        } finally {
            IoUtils.closeQuietly(conn);
        }
    }
}
```

### 二. 服务端处理请求

服务端提供了一个InstanceController类，在这个类中提供了服务注册相关的API，而服务端发起初测 时，调用的接口是： `[post]: /nacos/v1/ns/instance`

serviceName: 代表客户端的项目名称 

namespace: nacos 的namespace

> com.alibaba.nacos.naming.controllers.InstanceController#register

```java
@RestController
@RequestMapping(UtilsAndCommons.NACOS_NAMING_CONTEXT + "/instance")
public class InstanceController {
    @Autowired
    private SwitchDomain switchDomain;
    @Autowired
    private PushService pushService;
    
    @CanDistro
    @PostMapping
    @Secured(parser = NamingResourceParser.class, action = ActionTypes.WRITE)
    public String register(HttpServletRequest request) throws Exception {
		// 获取命名空间
        final String namespaceId = WebUtils.optional(request, CommonParams.NAMESPACE_ID, Constants.DEFAULT_NAMESPACE_ID);
        // 获取服务名称
        final String serviceName = WebUtils.required(request, CommonParams.SERVICE_NAME);
        // 检查服务名是否符合规范
        NamingUtils.checkServiceNameFormat(serviceName);
        // 从请求中解析出instance实例
        final Instance instance = parseInstance(request);

        serviceManager.registerInstance(namespaceId, serviceName, instance);
        return "ok";
    }
    
}
```

### ServiceManager.registerInstance

> com.alibaba.nacos.naming.core.ServiceManager#registerInstance

```java
public void registerInstance(String namespaceId, String serviceName, Instance instance) throws NacosException {
    // 创建一个空服务，在Nacos控制台服务列表展示的服务信息，实际上是初始化一个serviceMap，它是一个ConcurrentHashMap集合
    createEmptyService(namespaceId, serviceName, instance.isEphemeral());
	// 从serviceMap中，根据namespaceId和serviceName得到一个服务对象
    Service service = getService(namespaceId, serviceName);

    if (service == null) {
        throw new NacosException(NacosException.INVALID_PARAM, "service not found, namespace: " + namespaceId + ", service: " + serviceName);
    }
	// 调用addInstance创建一个服务实例
    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);
}
```

### createServiceIfAbsent

> registerInstance -> createEmptyService -> createServiceIfAbsent

```java
public void createServiceIfAbsent(String namespaceId, String serviceName, boolean local, Cluster cluster) throws NacosException {
    // 从serviceMap中获取服务对象
    Service service = getService(namespaceId, serviceName);
    if (service == null) { // 如果为空。则初始化

        Loggers.SRV_LOG.info("creating empty service {}:{}", namespaceId, serviceName);
        service = new Service();
        service.setName(serviceName);
        service.setNamespaceId(namespaceId);
        service.setGroupName(NamingUtils.getGroupName(serviceName));
        // now validate the service. if failed, exception will be thrown
        // 更新最后修改时间，这里后面会用来验证心跳存活
        service.setLastModifiedMillis(System.currentTimeMillis()); 
        service.recalculateChecksum(); // 重新计算服务的hash值
        if (cluster != null) {
            cluster.setService(service);
            service.getClusterMap().put(cluster.getName(), cluster);
        }
        service.validate();

        putServiceAndInit(service); // 存储service 并且初始化
        if (!local) {
            addOrReplaceService(service); // 添加或替换服务
        }
    }
}
```

### putServiceAndInit

> com.alibaba.nacos.naming.core.ServiceManager#putServiceAndInit

```java
private void putServiceAndInit(Service service) throws NacosException {
    //把服务信息保存到serviceMap集合
    putService(service);
    //建立心跳检测机制
    service.init();
    
    //实现数据一致性监听，ephemeral=true表示采用raft协议，false表示采用Distro协议
    consistencyService.listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), true), service);
    
    consistencyService.listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), false), service);
    
    Loggers.SRV_LOG.info("[NEW-SERVICE] {}", service.toJson());
}

// 1.将Service存储到ConcurrentHashMap
public void putService(Service service) {
    if (!serviceMap.containsKey(service.getNamespaceId())) {
        synchronized (putServiceLock) {
            if (!serviceMap.containsKey(service.getNamespaceId())) {
                serviceMap.put(service.getNamespaceId(), new ConcurrentSkipListMap<>());
            }
        }
    }
    serviceMap.get(service.getNamespaceId()).put(service.getName(), service);
}

// 2. Service 初始化
class Service {
    @JsonIgnore
    private ClientBeatCheckTask clientBeatCheckTask = new ClientBeatCheckTask(this);
    public void init() {
        HealthCheckReactor.scheduleCheck(clientBeatCheckTask); // 添加定时任务
        for (Map.Entry<String, Cluster> entry : clusterMap.entrySet()) {
            entry.getValue().setService(this);
            entry.getValue().init();
        }
    }
}
```

### addInstance

> InstanceController.register -> serviceManager.registerInstance -> addInstance

把服务实例添加到集合中，然后基于一致性协议进行数据的同步。

```java
public void addInstance(String namespaceId, String serviceName, boolean ephemeral, Instance... ips)
            throws NacosException {
	// 根据namespaceId、serviceName、ephemeral拼接key
    String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);
	// 查找服务
    Service service = getService(namespaceId, serviceName);

    synchronized (service) {
        // 更新一个服务下多个实例
        List<Instance> instanceList = addIpAddresses(service, ephemeral, ips);

        Instances instances = new Instances();
        instances.setInstanceList(instanceList);

        consistencyService.put(key, instances);
    }
}

// 根据 命名空间 与 服务名查找服务实例
public Service getService(String namespaceId, String serviceName) {
    if (serviceMap.get(namespaceId) == null) {
        return null;
    }
    // 服务实例结构：Map<String, Map<String, Service>> serviceMap = new ConcurrentHashMap<>();
    return chooseServiceMap(namespaceId).get(serviceName);
}

// 更新服务实例信息
public List<Instance> updateIpAddresses(
    Service service, 
    String action, 
    boolean ephemeral, 
    Instance... ips) throws NacosException {

    Datum datum = consistencyService.get(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), ephemeral));
	// 获取当前服务下的所有实例
    List<Instance> currentIPs = service.allIPs(ephemeral);
    Map<String, Instance> currentInstances = new HashMap<>(currentIPs.size());
    Set<String> currentInstanceIds = Sets.newHashSet();

    for (Instance instance : currentIPs) {
        currentInstances.put(instance.toIpAddr(), instance);
        currentInstanceIds.add(instance.getInstanceId());
    }

    Map<String, Instance> instanceMap;
    if (datum != null && null != datum.value) {
        instanceMap = setValid(((Instances) datum.value).getInstanceList(), currentInstances);
    } else {
        instanceMap = new HashMap<>(ips.length);
    }

    for (Instance instance : ips) {
        if (!service.getClusterMap().containsKey(instance.getClusterName())) {
            Cluster cluster = new Cluster(instance.getClusterName(), service);
            cluster.init();
            service.getClusterMap().put(instance.getClusterName(), cluster);
            Loggers.SRV_LOG
                .warn("cluster: {} not found, ip: {}, will create new cluster with default configuration.",
                      instance.getClusterName(), instance.toJson());
        }

        if (UtilsAndCommons.UPDATE_INSTANCE_ACTION_REMOVE.equals(action)) {
            instanceMap.remove(instance.getDatumKey());
        } else {
            instance.setInstanceId(instance.generateInstanceId(currentInstanceIds));
            instanceMap.put(instance.getDatumKey(), instance);
        }

    }

    if (instanceMap.size() <= 0 && UtilsAndCommons.UPDATE_INSTANCE_ACTION_ADD.equals(action)) {
        throw new IllegalArgumentException("ip list can not be empty, service: " + service.getName() + ", ip list: " + JacksonUtils.toJson(instanceMap.values()));
    }
    return new ArrayList<>(instanceMap.values());
}
```

## 消费者的服务查询

服务注册成功之后，消费者就可以从nacos server中获取到服务提供者的地址，然后进行服务的调用。

在服务消费中，有一个核心的类 NacosDiscoveryClient 来负责和nacos交互，去获得服务提供者的地址信息。前置的具体的流程就不在这里复述了，之前在讲dubbo源码的时候已经分析过服务的订阅过程。

`NacosDiscoveryClient` 中提供了一个 `getInstances` 方法用来根据服务提供者名称获取服务提供者的 url地址的方法.

### 一. 客户端启动获取服务列表

dubbo开启订阅操作，最终会到达 `FailbackRegistry` 调用 `subscribe` 方法。

> org.apache.dubbo.registry.support.FailbackRegistry#subscribe

### NacosDiscoveryClient.getInstances

> 执行流程：
>
> org.apache.dubbo.registry.support.FailbackRegistry#subscribe -> 
>
> com.alibaba.cloud.dubbo.registry.AbstractSpringCloudRegistry#doSubscribe -> 
>
> com.alibaba.cloud.dubbo.registry.AbstractSpringCloudRegistry#subscribeDubboServiceURLs -> 
>
> com.alibaba.cloud.dubbo.registry.AbstractSpringCloudRegistry#doSubscribeDubboServiceURLs ->
>
> com.alibaba.cloud.dubbo.registry.AbstractSpringCloudRegistry#getServiceInstances -> 
>
> com.alibaba.cloud.nacos.discovery.NacosDiscoveryClient#getInstances

```java
@Override
public List<ServiceInstance> getInstances(String serviceId) {
    try {
        return serviceDiscovery.getInstances(serviceId);
    }
    catch (Exception e) {
        throw new RuntimeException("Can not get hosts from nacos server. serviceId: " + serviceId, e);
    }
}
```

调用NamingService，根据serviceId、group获得服务实例列表。 

然后把instance转化为ServiceInstance对象

```java
public List<ServiceInstance> getInstances(String serviceId) throws NacosException {
    String group = discoveryProperties.getGroup();
    // 选择实例列表
    List<Instance> instances = discoveryProperties.namingServiceInstance().selectInstances(serviceId, group, true);
    return hostToServiceInstanceList(instances, serviceId);
}
```

### NacosNamingService.selectInstances

selectInstances首先从hostReactor获取serviceInfo，然后再从serviceInfo.getHosts()剔除非healty、 非enabled、weight小于等于0的instance再返回；如果subscribe为true，则执行 hostReactor.getServiceInfo获取serviceInfo，否则执行 hostReactor.getServiceInfoDirectlyFromServer获取serviceInfo

```java
@Override
public List<Instance> selectInstances(String serviceName, String groupName, List<String> clusters, boolean healthy, boolean subscribe) throws NacosException {

    ServiceInfo serviceInfo;
    if (subscribe) {// 是否订阅服务地址的变化，默认为true
        serviceInfo = hostReactor.getServiceInfo(NamingUtils.getGroupedName(serviceName, groupName), StringUtils.join(clusters, ","));
    } else {
        serviceInfo = hostReactor.getServiceInfoDirectlyFromServer(NamingUtils.getGroupedName(serviceName, groupName), StringUtils.join(clusters, ","));
    }
    return selectInstances(serviceInfo, healthy);
}
```

### HostReactor.getServiceInfo

```java
public ServiceInfo getServiceInfo(final String serviceName, final String clusters) {

    NAMING_LOGGER.debug("failover-mode: " + failoverReactor.isFailoverSwitch());
    // 拼接服务名称+集群名称（默认为空） 例：key=DEFAULT_GROUP@@nacos-dubbo-provider
    String key = ServiceInfo.getKey(serviceName, clusters);
    if (failoverReactor.isFailoverSwitch()) {
        return failoverReactor.getService(key);
    }
	// 从ServiceInfoMap中根据key来查找服务提供者列表，ServiceInfoMap是客户端的服务地址的本地缓存
    ServiceInfo serviceObj = getServiceInfo0(serviceName, clusters);

    if (null == serviceObj) {// 如果为空，表示本地缓存不存在
		// 如果找不到则创建一个新的然后放入serviceInfoMap，同时放入updatingMap，执行updateServiceNow，再从updatingMap移除；
        serviceObj = new ServiceInfo(serviceName, clusters);

        serviceInfoMap.put(serviceObj.getKey(), serviceObj);

        updatingMap.put(serviceName, new Object());
        updateServiceNow(serviceName, clusters); // 立马从Nacos server中去加载服务地址信息 
        updatingMap.remove(serviceName);

    } else if (updatingMap.containsKey(serviceName)) {
		//如果从serviceInfoMap找出来的serviceObj在updatingMap中则等待UPDATE_HOLD_INTERVAL；
        if (UPDATE_HOLD_INTERVAL > 0) {
            // hold a moment waiting for update finish
            synchronized (serviceObj) {
                try {
                    serviceObj.wait(UPDATE_HOLD_INTERVAL);
                } catch (InterruptedException e) {
                    NAMING_LOGGER.error("[getServiceInfo] serviceName:" + serviceName + ", clusters:" + clusters, e);
                }
            }
        }
    }
	// 如果本地缓存中存在，则通过scheduleUpdateIfAbsent开启定时任务，再从serviceInfoMap取出serviceInfo
    scheduleUpdateIfAbsent(serviceName, clusters);

    return serviceInfoMap.get(serviceObj.getKey());
}
```

上述代码中，有两个逻辑，分别是 

- updateServiceNow， 立马从Nacos server中去加载服务地址信息 
- scheduleUpdateIfAbsent 开启定时调度，每1s去查询一次服务地址

### updateServiceNow

```java
public void updateServiceNow(String serviceName, String clusters) {
    ServiceInfo oldService = getServiceInfo0(serviceName, clusters);
    try {
		// 请求 Nacos /instance/list API 获取服务列表
        String result = serverProxy.queryList(serviceName, clusters, pushReceiver.getUDPPort(), false);

        if (StringUtils.isNotEmpty(result)) {
            processServiceJSON(result); // 解析 返回的信息 并存放内存
        }
    } catch (Exception e) {
        NAMING_LOGGER.error("[NA] failed to update serviceName: " + serviceName, e);
    } finally {
        if (oldService != null) {
            synchronized (oldService) {
                oldService.notifyAll();
            }
        }
    }
}
```

### serverProxy.queryList

调用 `/nacos/v1/ns/instance/list` ，从Nacos server端获取服务地址信息。

```java
public String queryList(String serviceName, String clusters, int udpPort, boolean healthyOnly)
    throws NacosException {

    final Map<String, String> params = new HashMap<String, String>(8);
    params.put(CommonParams.NAMESPACE_ID, namespaceId);
    params.put(CommonParams.SERVICE_NAME, serviceName);
    params.put("clusters", clusters);
    params.put("udpPort", String.valueOf(udpPort));
    params.put("clientIP", NetUtils.localIP());
    params.put("healthyOnly", String.valueOf(healthyOnly));

    return reqAPI(UtilAndComs.NACOS_URL_BASE + "/instance/list", params, HttpMethod.GET);
}
```

### processServiceJSON

解析 nacos返回的服务列表信息 

```java
public ServiceInfo processServiceJSON(String json) {
    ServiceInfo serviceInfo = JSON.parseObject(json, ServiceInfo.class);
    ServiceInfo oldService = serviceInfoMap.get(serviceInfo.getKey());
    if (serviceInfo.getHosts() == null || !serviceInfo.validate()) {
        //empty or error push, just ignore
        return oldService;
    }

    boolean changed = false;

    if (oldService != null) {

        if (oldService.getLastRefTime() > serviceInfo.getLastRefTime()) {
            NAMING_LOGGER.warn("out of date data received, old-t: " + oldService.getLastRefTime()
                               + ", new-t: " + serviceInfo.getLastRefTime());
        }

        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);

        Map<String, Instance> oldHostMap = new HashMap<String, Instance>(oldService.getHosts().size());
        for (Instance host : oldService.getHosts()) {
            oldHostMap.put(host.toInetAddr(), host);
        }

        Map<String, Instance> newHostMap = new HashMap<String, Instance>(serviceInfo.getHosts().size());
        for (Instance host : serviceInfo.getHosts()) {
            newHostMap.put(host.toInetAddr(), host);
        }

        Set<Instance> modHosts = new HashSet<Instance>(); // 修改集合
        Set<Instance> newHosts = new HashSet<Instance>(); // 新增集合
        Set<Instance> remvHosts = new HashSet<Instance>(); // 删除集合

        List<Map.Entry<String, Instance>> newServiceHosts = new ArrayList<Map.Entry<String, Instance>>(
            newHostMap.entrySet());
        for (Map.Entry<String, Instance> entry : newServiceHosts) {
            Instance host = entry.getValue();
            String key = entry.getKey();
            if (oldHostMap.containsKey(key) && !StringUtils.equals(host.toString(),
                                                                   oldHostMap.get(key).toString())) {
                modHosts.add(host);
                continue;
            }

            if (!oldHostMap.containsKey(key)) {
                newHosts.add(host);
            }
        }

        for (Map.Entry<String, Instance> entry : oldHostMap.entrySet()) {
            Instance host = entry.getValue();
            String key = entry.getKey();
            if (newHostMap.containsKey(key)) {
                continue;
            }

            if (!newHostMap.containsKey(key)) {
                remvHosts.add(host);
            }

        }

        if (newHosts.size() > 0) {
            changed = true;
            NAMING_LOGGER.info("new ips(" + newHosts.size() + ") service: "
                               + serviceInfo.getKey() + " -> " + JSON.toJSONString(newHosts));
        }

        if (remvHosts.size() > 0) {
            changed = true;
            NAMING_LOGGER.info("removed ips(" + remvHosts.size() + ") service: "
                               + serviceInfo.getKey() + " -> " + JSON.toJSONString(remvHosts));
        }

        if (modHosts.size() > 0) {
            changed = true;
            NAMING_LOGGER.info("modified ips(" + modHosts.size() + ") service: "
                               + serviceInfo.getKey() + " -> " + JSON.toJSONString(modHosts));
        }

        serviceInfo.setJsonFromServer(json);

        if (newHosts.size() > 0 || remvHosts.size() > 0 || modHosts.size() > 0) {
            eventDispatcher.serviceChanged(serviceInfo);
            DiskCache.write(serviceInfo, cacheDir); // 存储磁盘
        }

    } else {
        changed = true;
        NAMING_LOGGER.info("init new ips(" + serviceInfo.ipCount() + ") service: " + serviceInfo.getKey() + " -> " + JSON
                           .toJSONString(serviceInfo.getHosts()));
        serviceInfoMap.put(serviceInfo.getKey(), serviceInfo);
        eventDispatcher.serviceChanged(serviceInfo);
        serviceInfo.setJsonFromServer(json);
        DiskCache.write(serviceInfo, cacheDir);
    }

    MetricsMonitor.getServiceInfoMapSizeMonitor().set(serviceInfoMap.size());

    if (changed) {
        NAMING_LOGGER.info("current ips:(" + serviceInfo.ipCount() + ") service: " + serviceInfo.getKey() +
                           " -> " + JSON.toJSONString(serviceInfo.getHosts()));
    }

    return serviceInfo;
}
```



# 服务动态更新

![](https://notebook1.oss-cn-shenzhen.aliyuncs.com/img/SpringCloudAlibaba/nacos/20201124143610.jpg)

## pull请求更新服务信息

### HostReactor.scheduleUpdateIfAbsent

在查询服务调用 getServiceInfo 方法的代码中，会开启一个定时任务，这个任务会在默认在1s之后开 始执行。而任务的具体实现是一个UpdateTask。

```java
public void scheduleUpdateIfAbsent(String serviceName, String clusters) {
    if (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != null) {
        return;
    }

    synchronized (futureMap) {
        if (futureMap.get(ServiceInfo.getKey(serviceName, clusters)) != null) {
            return;
        }

        ScheduledFuture<?> future = addTask(new UpdateTask(serviceName, clusters));
        futureMap.put(ServiceInfo.getKey(serviceName, clusters), future);
    }
}
```

### UpdateTask

```java
public class UpdateTask implements Runnable {
    long lastRefTime = Long.MAX_VALUE;
    private String clusters;
    private String serviceName;

    public UpdateTask(String serviceName, String clusters) {
        this.serviceName = serviceName;
        this.clusters = clusters;
    }

    @Override
    public void run() {
        try {
            //查询本地缓存
            ServiceInfo serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));

            if (serviceObj == null) { // 如果为空，则立刻发起更新
                updateServiceNow(serviceName, clusters);
                executor.schedule(this, DEFAULT_DELAY, TimeUnit.MILLISECONDS); // 并开启定时任务
                return;
            }

            if (serviceObj.getLastRefTime() <= lastRefTime) { // 判断服务是否已过期
                updateServiceNow(serviceName, clusters);
                serviceObj = serviceInfoMap.get(ServiceInfo.getKey(serviceName, clusters));
            } else {
                // 如果服务已经被基于push机制的情况下做了更新，那么我们不需要覆盖本地服务。
			   // 因为push过来的数据和pull数据不同，所以这里只是调用请求去刷新服务
                refreshOnly(serviceName, clusters);
            }
		   // 更新最后一次刷新时间
            lastRefTime = serviceObj.getLastRefTime();
  		   // 如果没有实现订阅或者futureMap中不包含指定服务信息，则中断更新请求
            if (!eventDispatcher.isSubscribed(serviceName, clusters) &&
                !futureMap.containsKey(ServiceInfo.getKey(serviceName, clusters))) {
                // abort the update task:
                NAMING_LOGGER.info("update task is stopped, service:" + serviceName + ", clusters:" + clusters);
                return;
            }
			// 延后10s执行
            executor.schedule(this, serviceObj.getCacheMillis(), TimeUnit.MILLISECONDS);


        } catch (Throwable e) {
            NAMING_LOGGER.warn("[NA] failed to update serviceName: " + serviceName, e);
        }

    }
}
```

## push请求推送数据

还记得在服务提供者发起服务注册时。在 createEmptyService 方法中，会创建一个空的服务

> com.alibaba.nacos.naming.core.ServiceManager#registerInstance

```java
public void registerInstance(String namespaceId, String serviceName, Instance instance) throws NacosException {
        
    createEmptyService(namespaceId, serviceName, instance.isEphemeral());

    Service service = getService(namespaceId, serviceName);

    if (service == null) {
        throw new NacosException(NacosException.INVALID_PARAM,
                                 "service not found, namespace: " + namespaceId + ", service: " + serviceName);
    }

    addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);
}
```

并且在这个创建过程中，调用了一个 `putServiceAndInit` ，这个方法中除了创建空的服务并且初始化，还会调用 `service.init` 方法进行服务的初始化

```java
public void createServiceIfAbsent(String namespaceId, String serviceName, boolean local, Cluster cluster) throws NacosException {
    Service service = getService(namespaceId, serviceName);
    if (service == null) {

        Loggers.SRV_LOG.info("creating empty service {}:{}", namespaceId, serviceName);
        service = new Service();
        service.setName(serviceName);
        service.setNamespaceId(namespaceId);
        service.setGroupName(NamingUtils.getGroupName(serviceName));
        // now validate the service. if failed, exception will be thrown
        service.setLastModifiedMillis(System.currentTimeMillis());
        service.recalculateChecksum();
        if (cluster != null) {
            cluster.setService(service);
            service.getClusterMap().put(cluster.getName(), cluster);
        }
        service.validate();

        putServiceAndInit(service);
        if (!local) {
            addOrReplaceService(service);
        }
    }
}

private void putServiceAndInit(Service service) throws NacosException {
    putService(service);
    service.init();
    consistencyService
        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), true), service);
    consistencyService
        .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), false), service);
    Loggers.SRV_LOG.info("[NEW-SERVICE] {}", service.toJson());
}
```

### service.init

这个init方法，会和当前服务提供者建立一个心跳检测机制，这个心跳检测会每5s执行一次。

```java
@JsonIgnore
private ClientBeatCheckTask clientBeatCheckTask = new ClientBeatCheckTask(this);


public void init() {
    HealthCheckReactor.scheduleCheck(clientBeatCheckTask);
    for (Map.Entry<String, Cluster> entry : clusterMap.entrySet()) {
        entry.getValue().setService(this);
        entry.getValue().init();
    }
}
```

### ClientBeatCheckTask.run

```java
public class ClientBeatCheckTask implements Runnable {
    
    @Override
    public void run() {
        try {
            if (!getDistroMapper().responsible(service.getName())) {
                return;
            }
            
            if (!getSwitchDomain().isHealthCheckEnabled()) {
                return;
            }
            
            List<Instance> instances = service.allIPs(true);
            
            // first set health status of instances:
            for (Instance instance : instances) { // 遍历服务节点进行心跳检测
                // 如果服务实例的最后一次心跳时间大于设置的超时时间，则认为这个服务已经下线。
                if (System.currentTimeMillis() - instance.getLastBeat() > instance.getInstanceHeartBeatTimeOut()) {
                    if (!instance.isMarked()) {
                        if (instance.isHealthy()) {
                            // 标记下线
                            instance.setHealthy(false);
                            Loggers.EVT_LOG.info("{POS} {IP-DISABLED} valid: {}:{}@{}@{}, region: {}, msg: client timeout after {}, last beat: {}", 
                                instance.getIp(), 
                                instance.getPort(), 
                                instance.getClusterName(),
                                service.getName(), 
                                UtilsAndCommons.LOCALHOST_SITE,
                                instance.getInstanceHeartBeatTimeOut(), 
                                instance.getLastBeat());
                            
                            getPushService().serviceChanged(service); // 推送服务变更事件。
                            ApplicationUtils.publishEvent(new InstanceHeartbeatTimeoutEvent(this, instance));
                        }
                    }
                }
            }
            
            if (!getGlobalConfig().isExpireInstance()) {
                return;
            }
            
            // then remove obsolete instances:
            for (Instance instance : instances) {
                
                if (instance.isMarked()) {
                    continue;
                }
                
                if (System.currentTimeMillis() - instance.getLastBeat() > instance.getIpDeleteTimeout()) {
                    // delete instance
                    Loggers.SRV_LOG.info("[AUTO-DELETE-IP] service: {}, ip: {}", 
                                         service.getName(), 
                                         JacksonUtils.toJson(instance));
                    
                    deleteIp(instance); //删除过期的服务实例
                }
            }
            
        } catch (Exception e) {
            Loggers.SRV_LOG.warn("Exception while processing client beat time out.", e);
        }
        
    }
}
```

### pushService.onApplicationEvent (推送服务变更事件)

监听服务状态变更事件，然后遍历所有的客户端，通过udp协议进行消息的广播通知

> com.alibaba.nacos.naming.push.PushService#onApplicationEvent

```java
@Override
public void onApplicationEvent(ServiceChangeEvent event) {
    Service service = event.getService();
    String serviceName = service.getName();
    String namespaceId = service.getNamespaceId();
	
    // 发送UDP
    Future future = GlobalExecutor.scheduleUdpSender(() -> {
        try {
            Loggers.PUSH.info(serviceName + " is changed, add it to push queue.");
            
            ConcurrentMap<String, PushClient> clients = clientMap.get(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));
            
            if (MapUtils.isEmpty(clients)) {
                return;
            }

            Map<String, Object> cache = new HashMap<>(16);
            long lastRefTime = System.nanoTime();
            for (PushClient client : clients.values()) {
                if (client.zombie()) {
                    Loggers.PUSH.debug("client is zombie: " + client.toString());
                    clients.remove(client.toString());
                    Loggers.PUSH.debug("client is zombie: " + client.toString());
                    continue;
                }

                Receiver.AckEntry ackEntry;
                Loggers.PUSH.debug("push serviceName: {} to client: {}", serviceName, client.toString());
                String key = getPushCacheKey(serviceName, client.getIp(), client.getAgent());
                byte[] compressData = null;
                Map<String, Object> data = null;
                if (switchDomain.getDefaultPushCacheMillis() >= 20000 && cache.containsKey(key)) {
                    org.javatuples.Pair pair = (org.javatuples.Pair) cache.get(key);
                    compressData = (byte[]) (pair.getValue0());
                    data = (Map<String, Object>) pair.getValue1();

                    Loggers.PUSH.debug("[PUSH-CACHE] cache hit: {}:{}", serviceName, client.getAddrStr());
                }

                if (compressData != null) {
                    ackEntry = prepareAckEntry(client, compressData, data, lastRefTime);
                } else {
                    ackEntry = prepareAckEntry(client, prepareHostsData(client), lastRefTime);
                    if (ackEntry != null) {
                        cache.put(key, new org.javatuples.Pair<>(ackEntry.origin.getData(), ackEntry.data));
                    }
                }

                Loggers.PUSH.info("serviceName: {} changed, schedule push for: {}, agent: {}, key: {}", client.getServiceName(), client.getAddrStr(), client.getAgent(), (ackEntry == null ? null : ackEntry.key));

                udpPush(ackEntry); // UDP推送 下线的服务实例
            }
        } catch (Exception e) {
            Loggers.PUSH.error("[NACOS-PUSH] failed to push serviceName: {} to client, error: {}", serviceName, e);

        } finally {
            futureMap.remove(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName));
        }
    }, 1000, TimeUnit.MILLISECONDS);

    futureMap.put(UtilsAndCommons.assembleFullServiceName(namespaceId, serviceName), future);

}
```

那么服务消费者此时应该是建立了一个udp服务的监听，否则服务端无法进行数据的推送。这个监听是 在HostReactor的构造方法中初始化的

### HostReactor

初始化了一个DatagramSocket，这是一个Udp的socket连接，开启一个线程，定时执行当前任务

```java
public HostReactor(NamingProxy serverProxy, BeatReactor beatReactor, String cacheDir, boolean loadCacheAtStart, int pollingThreadCount) {
    // init executorService
    this.executor = new ScheduledThreadPoolExecutor(pollingThreadCount, new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setDaemon(true);
            thread.setName("com.alibaba.nacos.client.naming.updater");
            return thread;
        }
    });

    this.beatReactor = beatReactor;
    this.serverProxy = serverProxy;
    this.cacheDir = cacheDir;
    if (loadCacheAtStart) {
        // 读取本地缓存文件
        this.serviceInfoMap = new ConcurrentHashMap<String, ServiceInfo>(DiskCache.read(this.cacheDir));
    } else {
        this.serviceInfoMap = new ConcurrentHashMap<String, ServiceInfo>(16);
    }

    this.updatingMap = new ConcurrentHashMap<String, Object>();
    this.failoverReactor = new FailoverReactor(this, cacheDir);
    this.pushReceiver = new PushReceiver(this);
    this.notifier = new InstancesChangeNotifier();

    NotifyCenter.registerToPublisher(InstancesChangeEvent.class, 16384);
    NotifyCenter.registerSubscriber(notifier);
}
```

在run方法中，不断循环监听服务端的push请求。然后调用 processServiceJSON 对服务端的数据进行解析。

> com.alibaba.nacos.client.naming.core.PushReceiver#run

```java
@Override
public void run() {
    while (!closed) {
        try {

            // byte[] is initialized with 0 full filled by default
            byte[] buffer = new byte[UDP_MSS];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

            udpSocket.receive(packet);

            String json = new String(IoUtils.tryDecompress(packet.getData()), UTF_8).trim();
            NAMING_LOGGER.info("received push data: " + json + " from " + packet.getAddress().toString());

            PushPacket pushPacket = JacksonUtils.toObj(json, PushPacket.class);
            String ack;
            if ("dom".equals(pushPacket.type) || "service".equals(pushPacket.type)) {
                hostReactor.processServiceJson(pushPacket.data);

                // send ack to server
                ack = "{\"type\": \"push-ack\"" + ", \"lastRefTime\":\"" + pushPacket.lastRefTime + "\", \"data\":\"\"}";
            } else if ("dump".equals(pushPacket.type)) {
                // dump data to server
                ack = "{\"type\": \"dump-ack\"" + ", \"lastRefTime\": \"" + pushPacket.lastRefTime + "\", \"data\":\"" + StringUtils.escapeJavaScript(JacksonUtils.toJson(hostReactor.getServiceInfoMap())) + "\"}";
            } else {
                // do nothing send ack only
                ack = "{\"type\": \"unknown-ack\"" + ", \"lastRefTime\":\"" + pushPacket.lastRefTime
                    + "\", \"data\":" + "\"\"}";
            }

            udpSocket.send(new DatagramPacket(ack.getBytes(UTF_8), ack.getBytes(UTF_8).length,
                                              packet.getSocketAddress()));
        } catch (Exception e) {
            if (closed) {
                return;
            }
            NAMING_LOGGER.error("[NA] error while receiving push data", e);
        }
    }
}
```

